<!DOCTYPE html>
<html lang=zh-TW>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="Redis 可謂是當前最知名的 In-memory Database ，常常被拿來當快取資料庫。 由 C 語言撰寫的 Redis 為鍵值對（ Key - Value ）資料庫，資料皆儲存於 Memory 所以讀寫的速度非常快，只不過這導致 Redis 若不小心關閉，所有資料會直接消失。因此它也提供可選的持久化設定，開啟的話可以在某種程度上避免資料遺失。 可以想成 Redis 是一個獨立於程式外的高">
<meta name="keywords" content="淺入淺出,redis">
<meta property="og:type" content="article">
<meta property="og:title" content="淺入淺出 Redis">
<meta property="og:url" content="https:&#x2F;&#x2F;nekowarabe.github.io&#x2F;2019&#x2F;11&#x2F;06&#x2F;redis-intro-md&#x2F;index.html">
<meta property="og:site_name" content="Neko In Boots">
<meta property="og:description" content="Redis 可謂是當前最知名的 In-memory Database ，常常被拿來當快取資料庫。 由 C 語言撰寫的 Redis 為鍵值對（ Key - Value ）資料庫，資料皆儲存於 Memory 所以讀寫的速度非常快，只不過這導致 Redis 若不小心關閉，所有資料會直接消失。因此它也提供可選的持久化設定，開啟的話可以在某種程度上避免資料遺失。 可以想成 Redis 是一個獨立於程式外的高">
<meta property="og:locale" content="zh-TW">
<meta property="og:updated_time" content="2019-11-06T14:19:06.341Z">
<meta name="twitter:card" content="summary">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>淺入淺出 Redis</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><b><a href="/">首頁</a></b></li>
         
          <li><b><a href="/about/">關於</a></b></li>
         
          <li><b><a href="/archives/">雜學</a></b></li>
         
          <li><b><a href="/categories/">分類</a></b></li>
         
          <li><b><a href="/search/">搜尋</a></b></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" href="/2019/10/29/hello-world/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">較新的</span>
      <span id="i-next" class="info" style="display:none;">較舊的</span>
      <span id="i-top" class="info" style="display:none;">回到開頭</span>
      <span id="i-share" class="info" style="display:none;">分享</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://nekowarabe.github.io/2019/11/06/redis-intro-md/" target="_blank" rel="noopener"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://nekowarabe.github.io/2019/11/06/redis-intro-md/&text=淺入淺出 Redis" target="_blank" rel="noopener"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://nekowarabe.github.io/2019/11/06/redis-intro-md/&title=淺入淺出 Redis" target="_blank" rel="noopener"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://nekowarabe.github.io/2019/11/06/redis-intro-md/&is_video=false&description=淺入淺出 Redis" target="_blank" rel="noopener"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=淺入淺出 Redis&body=Check out this article: https://nekowarabe.github.io/2019/11/06/redis-intro-md/" target="_blank" rel="noopener"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://nekowarabe.github.io/2019/11/06/redis-intro-md/&title=淺入淺出 Redis" target="_blank" rel="noopener"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://nekowarabe.github.io/2019/11/06/redis-intro-md/&title=淺入淺出 Redis" target="_blank" rel="noopener"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://nekowarabe.github.io/2019/11/06/redis-intro-md/&title=淺入淺出 Redis" target="_blank" rel="noopener"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://nekowarabe.github.io/2019/11/06/redis-intro-md/&title=淺入淺出 Redis" target="_blank" rel="noopener"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://nekowarabe.github.io/2019/11/06/redis-intro-md/&name=淺入淺出 Redis&description=" target="_blank" rel="noopener"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-特色？"><span class="toc-number">1.</span> <span class="toc-text">Redis 特色？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#單執行緒？"><span class="toc-number">1.1.</span> <span class="toc-text">單執行緒？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#引入多執行緒？"><span class="toc-number">1.2.</span> <span class="toc-text">引入多執行緒？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#啟動與連線"><span class="toc-number">2.</span> <span class="toc-text">啟動與連線</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#密碼"><span class="toc-number">2.1.</span> <span class="toc-text">密碼</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#設定檔"><span class="toc-number">2.2.</span> <span class="toc-text">設定檔</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用操作"><span class="toc-number">3.</span> <span class="toc-text">常用操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#String"><span class="toc-number">3.1.</span> <span class="toc-text">String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List"><span class="toc-number">3.2.</span> <span class="toc-text">List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set"><span class="toc-number">3.3.</span> <span class="toc-text">Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash"><span class="toc-number">3.4.</span> <span class="toc-text">Hash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sorted-Set"><span class="toc-number">3.5.</span> <span class="toc-text">Sorted Set</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事務"><span class="toc-number">4.</span> <span class="toc-text">事務</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原理"><span class="toc-number">4.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lua-Script"><span class="toc-number">4.2.</span> <span class="toc-text">Lua Script</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#參考資料"><span class="toc-number">5.</span> <span class="toc-text">參考資料</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        淺入淺出 Redis
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Nekowarabe</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2019-11-06T12:21:22.000Z" itemprop="datePublished">2019-11-06</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/%E7%A8%8B%E5%BC%8F/">程式</a> › <a class="category-link" href="/categories/%E7%A8%8B%E5%BC%8F/%E8%B3%87%E6%96%99%E5%BA%AB/">資料庫</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/redis/" rel="tag">redis</a>, <a class="tag-link" href="/tags/%E6%B7%BA%E5%85%A5%E6%B7%BA%E5%87%BA/" rel="tag">淺入淺出</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>Redis 可謂是當前最知名的 In-memory Database ，常常被拿來當快取資料庫。</p>
<p>由 C 語言撰寫的 Redis 為鍵值對（ Key - Value ）資料庫，資料皆儲存於 Memory 所以讀寫的速度非常快，只不過這導致 Redis 若不小心關閉，所有資料會直接消失。因此它也提供可選的持久化設定，開啟的話可以在某種程度上避免資料遺失。</p>
<p>可以想成 Redis 是一個獨立於程式外的高級 Map （或稱 Dict ），提供許多更進階的功能。</p>
<h2 id="Redis-特色？"><a href="#Redis-特色？" class="headerlink" title="Redis 特色？"></a>Redis 特色？</h2><p>Redis 採用單執行緒設計，雖然 4.0 之後有選擇多執行緒，但這不改變核心概念，那就是：『操作命令皆為單執行緒處理』。</p>
<h3 id="單執行緒？"><a href="#單執行緒？" class="headerlink" title="單執行緒？"></a>單執行緒？</h3><p>單執行緒最大的一個特點就是不必擔心<strong>資料競爭</strong>。</p>
<p>假如使用了多執行緒，為了避免競爭問題勢必得加入鎖（ Lock ）的機制，有經驗的人都很清楚這個機制要妥善處理有多麻煩吧？除了每次上鎖與解鎖的額外消耗，還得注意忘了取鎖、解鎖引發的問題。</p>
<p>此外， Redis 性能瓶頸不是來自於 CPU ，官方的 <a href="https://redis.io/topics/faq#redis-is-single-threaded-how-can-i-exploit-multiple-cpu--cores" target="_blank" rel="noopener" title="Redis is single threaded">FQA</a> 也說了：</p>
<blockquote>
<p>It’s not very frequent that CPU becomes your bottleneck with Redis, as usually Redis is either memory or network bound. For instance, using pipelining Redis running on an average Linux system can deliver even 1 million requests per second, so if your application mainly uses O(N) or O(log(N)) commands, it is hardly going to use too much CPU.</p>
</blockquote>
<p>即使在普通的 Linux 系統上啟動 Redis ，也能在 1sec 的時間內服務 1,000,000 個請求。</p>
<h3 id="引入多執行緒？"><a href="#引入多執行緒？" class="headerlink" title="引入多執行緒？"></a>引入多執行緒？</h3><p>確實在 4.0 版本中 Redis 引入多執行緒，這是因為後續加入了可異步處理的刪除操作。</p>
<table>
<thead>
<tr>
<th align="left">Async</th>
<th align="left">Sync</th>
</tr>
</thead>
<tbody><tr>
<td align="left">UNLINK</td>
<td align="left">DEL</td>
</tr>
<tr>
<td align="left">FLUSHALL ASYNC</td>
<td align="left">FLUSHALL</td>
</tr>
<tr>
<td align="left">FLUSHDB ASYNC</td>
<td align="left">FLUSHDB</td>
</tr>
</tbody></table>
<p>要刪除容量不大（ Memory Size ）的鍵值對不會花太多功夫，所以就算單執行緒<strong>同步地</strong>刪除也不太會阻塞到其它操作。</p>
<p>不過 Redis 也可能有巨型資料存在，動輒十幾 MB 或是幾百 MB 都可能，而這種龐大的資料不可能短時間內處理完，這樣會導致其它操作卡住。</p>
<p>異步版本的刪除命令，原理是先將 Key 給移除，而實際上 Value 的刪除則是透過其它執行緒來執行，這樣就可以在刪除大型資料時也不導致 Redis 卡住。</p>
<p>至於在 6.0 的多執行緒 I/O 主要是用來處理網路的讀寫，也就是實際上命令的執行依然維持在單執行緒。</p>
<h2 id="啟動與連線"><a href="#啟動與連線" class="headerlink" title="啟動與連線"></a>啟動與連線</h2><p>Redis 服務啟動時沒有傳入任何參數的話，預設會監聽 Port 6379 ，可以透過 <code>--port</code> 或是指定設定檔，但是設定檔要自己建立。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 透過參數指定 Port</span></span><br><span class="line">$ redis-server --port 6666</span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過設定檔</span></span><br><span class="line">$ redis-server redis.conf</span><br></pre></td></tr></table></figure>

<p>之後就可以藉由 redis-cli 來連線到 Redis ，直接執行時如果沒設定參數，會連向本地的 6379 。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<p>要遠端連接需要透過 <code>-h</code> 指定 Host ； <code>-p</code> 指定 Port 。</p>
<h3 id="密碼"><a href="#密碼" class="headerlink" title="密碼"></a>密碼</h3><p>Redis 是可以設置密碼的，有兩種方式，分別是設定檔與操作命令。</p>
<p>設定檔只需要加入 <code>requirepass PASSWORD</code> 這段訊息，並在 Redis Server 啟動時指定使用該設定檔即可。</p>
<p>透過命令的話先連線至已啟動的 Redis Server ：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先連線到 Redis Server</span></span><br><span class="line">$ redis-cli</span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的命令可以看目前密碼是否有設置</span></span><br><span class="line">127.0.0.1:6379&gt; CONFIG GET requirepass</span><br><span class="line">1) <span class="string">"requirepass"</span></span><br><span class="line">2) <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過 SET 來設置密碼（ requirepass ）</span></span><br><span class="line">127.0.0.1:6379&gt; CONFIG SET requirepass <span class="string">"PASSWORD"</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>當看到 OK 後如果在執行一次 GET 會出現錯誤訊息「 (error) NOAUTH Authentication required. 」，這樣就得透過認證命令來獲取權限：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; AUTH <span class="string">"PASSWORD"</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>除了透過這種方式登入有設定密碼的 Redis ，也可以在執行 redis-cli 時透過 <code>-a</code> 來傳遞密碼：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -a PASSWORD</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<p>但這種方式並不推薦，原因在於 <code>-a</code> 送出的密碼會是明文傳遞，很容易被他人攔截到，所以大多情況還是建議使用 <code>AUTH</code> 命令來驗證。</p>
<blockquote>
<p>注意要移除密碼不是透過 <code>DEL</code> ，而是要透過 <code>SET</code> 將密碼設定為 “” （空字串）</p>
</blockquote>
<h3 id="設定檔"><a href="#設定檔" class="headerlink" title="設定檔"></a>設定檔</h3><p>Redis 啟動時都會使用一組設定檔，沒有指定時會使用預設值。</p>
<p>設定檔可以指定多種不同的資訊，如前述的密碼，或是開啟主從式架構的關係等，如果想知道當前的設定檔資訊，可以透過前綴 <code>CONFIG</code> 搭配 <code>GET</code> 。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 回傳的訊息中，奇數為設定的名稱；偶數為設定的值</span></span><br><span class="line">127.0.0.1:6379&gt; CONFIG GET *</span><br><span class="line">1) <span class="string">"dbfilename"</span></span><br><span class="line">2) <span class="string">"dump.rdb"</span></span><br><span class="line">3) <span class="string">"requirepass"</span></span><br><span class="line">4) <span class="string">""</span></span><br><span class="line">...</span><br><span class="line">213) <span class="string">"bind"</span></span><br><span class="line">214) <span class="string">""</span></span><br></pre></td></tr></table></figure>

<p>另外也能用 <code>INFO</code> 命令可以看當前 Redis 的相關資訊。</p>
<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><p>說起 Map 結構，其實核心操作不過就是 Get 與 Set 而已。</p>
<p>Redis 支援多種資料型態：</p>
<ol>
<li>String</li>
<li>List</li>
<li>Set</li>
<li>Hash</li>
<li>Sorted Set</li>
<li>Bitmap</li>
<li>HyperLogLog</li>
</ol>
<p>後面有兩個詭異的型態，但這邊先不介紹，通常我們會使用的應該只有前幾個，大部分的命令可以<a href="https://redis.io/commands" target="_blank" rel="noopener" title="Redis Commands">到此</a>查詢。</p>
<blockquote>
<p>上列表中沒有出現 Number / Numeric 型態，因為 Redis 會把值都會轉換成 String 儲存，因此部份與數字相關的操作（ <code>INCR</code> 、 <code>DECR</code> ），實際上都是先將其轉換為數字才處理</p>
</blockquote>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>可以透過 <code>SET</code> 設置指定 Key 與其相對的 Value （型態為 String ），也能藉由 <code>GET</code> 取出。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 設定 name - Neko 鍵值對</span></span><br><span class="line">127.0.0.1:6379&gt; SET name <span class="string">"Neko"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 藉由 Key 取出對應的 Value</span></span><br><span class="line">127.0.0.1:6379&gt; GET name</span><br><span class="line"><span class="string">"Neko"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 讀取不存在的 Key 會收到 nil</span></span><br><span class="line">127.0.0.1:6379&gt; GET neko</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<p>如果值不包含空白，可以不加入雙引號：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SET name Neko</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; GET name</span><br><span class="line">&quot;Neko&quot;</span><br></pre></td></tr></table></figure>

<p>當儲存的 Value 是可以被轉換成數字（ Integer 、 Float ），就可以使用數字相關的操作，好比說加減的 <code>INCR</code> 與 <code>DECR</code> （各自等於 <code>INCRBY 1</code> 與 <code>DECRBY 1</code> ）。</p>
<blockquote>
<p>如果增減的值屬於浮點數請改用 <code>INCRBYFLOAT</code> ，否則會出現型態轉換錯誤</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 設置數字的 Value</span></span><br><span class="line">127.0.0.1:6379&gt; SET num <span class="string">"1"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過 INCR 加一，會回傳加完後的值</span></span><br><span class="line">127.0.0.1:6379&gt; INCR num</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 想指定增加的值就需使用 INCRBY</span></span><br><span class="line">127.0.0.1:6379&gt; INCRBY num 3</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 減的操作相似，不用加上負號</span></span><br><span class="line">127.0.0.1:6379&gt; DECRBY num 3</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增減的值如果是 Float 就需用 INCRBYFLOAT （不論加或減）</span></span><br><span class="line">127.0.0.1:6379&gt; INCRBYFLOAT num 0.5</span><br><span class="line"><span class="string">"2.5"</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; INCRBYFLOAT num -0.5</span><br><span class="line"><span class="string">"2"</span></span><br></pre></td></tr></table></figure>

<p>注意，對於 <code>INCRBY</code> 與 <code>DECRBY</code> 命令的回傳值都會做 Integer 轉換，所以假使你的值為 Float ，那麼回傳值可能會出現錯誤「 (error) ERR value is not an integer or out of range 」。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SET f 0.5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 這種情況下會視為失敗，會保持原本的值</span></span><br><span class="line">127.0.0.1:6379&gt; INCR f</span><br><span class="line">(error) ERR value is not an <span class="built_in">integer</span> or out of range</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; GET f</span><br><span class="line"><span class="string">"0.5"</span></span><br></pre></td></tr></table></figure>

<p>也有命令可以一次存取多個鍵值對，這些命令前方會多 M （ <code>MSET</code> 、 <code>MGET</code> ），用法基本上是沒有差別的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 透過空白隔離多個鍵值對</span></span><br><span class="line">127.0.0.1:6379&gt; MSET name <span class="string">"Doge"</span> age <span class="string">"66"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取出時會依照輸入 Key 的順序</span></span><br><span class="line">127.0.0.1:6379&gt; MGET age name</span><br><span class="line">1) <span class="string">"66"</span></span><br><span class="line">2) <span class="string">"Doge"</span></span><br></pre></td></tr></table></figure>

<p>Redis 在設值時有提供多種方式，可以在特定條件下才設值。<br>原本這些命令都被拆分開來，但在 2.6.12 時可以透過 <code>SET</code> 參數方式使用。</p>
<table>
<thead>
<tr>
<th align="left">Command</th>
<th align="left">Option</th>
<th align="center">Desc</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SETEX</td>
<td align="left">EX</td>
<td align="center">指定過期時間，到了以後會移除（ second ）</td>
</tr>
<tr>
<td align="left">PSETEX</td>
<td align="left">PX</td>
<td align="center">指定過期時間，到了以後會移除（ millisecond ）</td>
</tr>
<tr>
<td align="left">SETNX</td>
<td align="left">NX</td>
<td align="center">當 Key 不存在時才設值</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">XX</td>
<td align="center">當 Key 存在時才設值</td>
</tr>
</tbody></table>
<p>透過參數形式的好處是可以混合多種 Option ，好比說我希望在沒有 Key 時設值，且這個值有效時間只有 10 秒，這種情況只能透過 Option 的方式設定。</p>
<blockquote>
<p>官方已不再建議使用 Command 形式，上面的三個命令可能會在未來被移除</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下方兩種方式結果是一樣的</span></span><br><span class="line">127.0.0.1:6379&gt; SET secret <span class="string">"abc123"</span> EX 10</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SETEX secret 10 <span class="string">"abc123"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 混合 Option 當 Key 不存在才設值且有效時間為 5 秒</span></span><br><span class="line">127.0.0.1:6379&gt; SET secret <span class="string">"abc123"</span> NX EX 5</span><br></pre></td></tr></table></figure>

<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>Redis 的 List 是單純的 String List ，使用時可以將元素放入頭或尾。<br>其實就是 Linked List ，據官方的說明可以儲存 2^32 - 1 個元素（ 4,294,967,295 ）。</p>
<p>增加元素時會確認是否已存在 List ，不存在時會自動建立，而透過命令移除元素時如果會使 List 為空，則會移除該 Key 。</p>
<blockquote>
<p>意思是如果 List 被清空，那麼等於此 Key 沒被設置過</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 元素放入的方式有左與右（ LPUSH 、 RPUSH ），並回傳當前 List 長度</span></span><br><span class="line">127.0.0.1:6379&gt; LPUSH nums <span class="string">"10"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; RPUSH nums <span class="string">"20"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># LRANGE 可以取出指定 Key 的 Start Index 到 End Index 的值</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE nums 0 -1</span><br><span class="line">1) <span class="string">"10"</span></span><br><span class="line">2) <span class="string">"20"</span></span><br></pre></td></tr></table></figure>

<p>Index 的部分支援逆向，所以例子的 -1 意思是倒數最後一個元素，整條命令就是取出 List 上所有元素。</p>
<p>取出元素可以基於 Index 或是如 Queue 一樣在取值時會將其移出 List ，前者就如同程式語言內常用的 List[Index] 操作；後者則是 Queue 的 Pop 操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下會建立出 [10, 20, 30] 的陣列</span></span><br><span class="line">127.0.0.1:6379&gt; RPUSH nums <span class="string">"10"</span> <span class="string">"20"</span> <span class="string">"30"</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基於 Index 取值，但不會移出 List</span></span><br><span class="line">127.0.0.1:6379&gt; LINDEX nums 0</span><br><span class="line"><span class="string">"10"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 從左取出第一個元素，並移出 List</span></span><br><span class="line">127.0.0.1:6379&gt; LPOP nums</span><br><span class="line"><span class="string">"10"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 從右取出第一個元素，並移出 List</span></span><br><span class="line">127.0.0.1:6379&gt; RPOP nums</span><br><span class="line"><span class="string">"30"</span></span><br></pre></td></tr></table></figure>

<p>Pop 相關的操作還有提供 Block 版本，表示如果 Pop 的對象沒有任何元素可以取出，那麼連線將 Block 直到有元素可以回傳或超時。</p>
<p>命令需給予超時時限（ second ），但如果給 0 則表示無限制。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果 nums 左有元素可以取出，則效果同 LPOP 否則會卡在此處直到有元素可回傳或 30 秒後</span></span><br><span class="line">127.0.0.1:6379&gt; BLPOP nums 30</span><br><span class="line">(nil)</span><br><span class="line">(30.9s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有元素的情況就如同一般 POP</span></span><br><span class="line">127.0.0.1:6379&gt; LPUSH nums <span class="string">"1"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; BLPOP nums 30</span><br><span class="line"><span class="string">"1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以一次 Block 監聽多個 Key 有沒有元素，會回傳第一個不為空的元素</span></span><br><span class="line">127.0.0.1:6379&gt; BLPOP nums names ages 30</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>單執行緒的 Redis 在處理 Block 時，會透過 Dict 來儲存 Key 與等待者的資訊，好比說 ClientID 。並在每次處理命令時都檢查是否有元素可以提供。</p>
<p>當然如果是這樣會導致每次跑命令都浪費時間，所以 Redis 利用兩個 Dict 來記錄，名稱分別為 <strong>blocking_keys</strong> 與 <strong>ready_keys</strong> 。</p>
<ul>
<li>blocking_keys<br>  為 Key : List&lt;Client&gt; 的 Dict ，記錄著有人等待的 Key 與等待者相關訊息。</li>
<li>ready_keys<br>  當 Push 的 Key 為空 List 時會檢查該 Key 是否存在於 blocking_keys 內，有的話會將相關訊息放入 ready_keys ，也是每次 Redis 處理命令時會檢查的對象。</li>
</ul>
<p>所以實際上只有在處理 Push 相關訊息時才會檢查 Block 名單，如果該 key 剛好在 Block 名單中就透過 Ready 名單通知 Server 與 Client 。</p>
<blockquote>
<p>在 <code>MULTI</code> / <code>EXEC</code> 中使用 Block 的命令，會因為交易原子性問題馬上回應，效用等同於非 Block 操作</p>
</blockquote>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Redis 的 Set 為無序的 String 集合，據官方所說可儲存的數量與 List 同樣為 2^32 - 1 個（ 4,294,967,295 ）。</p>
<p>與常見的 Set 結構一樣，內部的元素是不允許重複的。</p>
<p>透過 <code>SADD</code> 可以替 Set 放入元素，要是想確認某個元素是否存在於 Set 需要透過 <code>SISMEMBER</code> 。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SADD 可以一次放入多樣值，回傳 Set 操作後的元素數量</span></span><br><span class="line">127.0.0.1:6379&gt; SADD unique <span class="string">"Neko"</span> <span class="string">"Doge"</span> <span class="string">"Neko"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢查指定元素是否存在，回傳 Integer 存在為 1 ；不存在為 0</span></span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER unique <span class="string">"Neko"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER unique <span class="string">"Jacky"</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<p>移除 Set 內的資料可以透過 <code>SPOP</code> 與 <code>SREM</code> ，<br>但前者是<strong>隨機地</strong>移除指定 Set 的元素，後者才可以指定移除。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SADD unique <span class="string">"A"</span> <span class="string">"B"</span> <span class="string">"C"</span> <span class="string">"D"</span> <span class="string">"E"</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 隨機移除兩個元素，數量省略時預設為 1</span></span><br><span class="line">127.0.0.1:6379&gt; SPOP unique 2</span><br><span class="line">1) <span class="string">"B"</span></span><br><span class="line">2) <span class="string">"D"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除指定元素， 2.4 之後可以一次移除多個，會回傳被移除的數量</span></span><br><span class="line">127.0.0.1:6379&gt; SREM unique <span class="string">"A"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假使移除不存在的元素也可以，但不會包含在移除數量中</span></span><br><span class="line">127.0.0.1:6379&gt; SREM unique <span class="string">"A"</span> <span class="string">"B"</span> <span class="string">"C"</span> <span class="string">"D"</span> <span class="string">"E"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure>


<p>如果想確認 Set 目前的數量可以用 <code>SCARD</code> ，不過想知道目前裡面所有的元素內容就得透過 <code>SMEMBERS</code> 。後者的速度比較慢，以時間複雜度來說前者為 O(1) 後者為 O(N) 。</p>
<p>Set 本身也有比較進階的操作，好比說交集（ <code>SINTER</code> ）、聯集（ <code>SUNION</code> ）、差集（ <code>SDIFF</code> ）等，除了聯集以外，另外兩個都是以第一個 Set 為基礎去處理，而非把每個 Set 都視為平等。</p>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>Hash 就是鍵值皆為 String 的 Map 結構，也因此很適合用來模擬 Object 。當然，據官方所說 Hash 同樣可以儲存 2^32 - 1 組鍵值對。</p>
<p>以一個 JSON 物件來當例子可以更好理解 Hash 如何模擬物件：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"Neko"</span>,</span><br><span class="line">    <span class="attr">"age"</span>: <span class="number">66</span>,</span><br><span class="line">    <span class="attr">"level"</span>: <span class="string">"normal"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述為擁有編號、名稱、等級等資訊的 User 物件，透過 <code>HSET</code> 來設置這個物件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 設置成功後會回傳成功加入的鍵值對數量</span></span><br><span class="line">127.0.0.1:6379&gt; HSET user:100 id 100</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.0 之後 HSET 允許一次設定多組鍵值對</span></span><br><span class="line">127.0.0.1:6379&gt; HSET user:100 name <span class="string">"Neko"</span> age 66 level <span class="string">"normal"</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.0 之前要設定多組得透過 HMSET</span></span><br><span class="line">127.0.0.1:6379&gt; HMSET user:100 name <span class="string">"Neko"</span> age 66 level <span class="string">"normal"</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure>

<p>回傳的值是被<strong>新加入</strong>的鍵值對數量，換句話說修改是不包含在內的，這種情況會收到 0 。</p>
<blockquote>
<p>Redis 建議命名 Key 時如果有不同區段訊息，應該透過 <code>:</code> 來區隔而不是 <code>_</code></p>
</blockquote>
<p>雖說上面的例子是模擬 Object ，但是身為 Map 結構該有的操作都沒少，例如讀取某個 Key 對應的 Value ，或取出目前所有 Key 、 Value 等命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 單獨取用某個 Key 的值</span></span><br><span class="line">127.0.0.1:6379&gt; HGET user:100 name</span><br><span class="line"><span class="string">"Neko"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只取出對象目前所有的 Key</span></span><br><span class="line">127.0.0.1:6379&gt; HKEYS user:100</span><br><span class="line">1) <span class="string">"id"</span></span><br><span class="line">2) <span class="string">"name"</span></span><br><span class="line">3) <span class="string">"age"</span></span><br><span class="line">4) <span class="string">"level"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只取出對象目前所有的 Value</span></span><br><span class="line">127.0.0.1:6379&gt; HVALS user:100</span><br><span class="line">1) <span class="string">"100"</span></span><br><span class="line">2) <span class="string">"Neko"</span></span><br><span class="line">3) <span class="string">"66"</span></span><br><span class="line">4) <span class="string">"normal"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把全部鍵值對都取出來，奇數為 Key ；偶數為 Value</span></span><br><span class="line">127.0.0.1:6379&gt; GETALL user:100</span><br><span class="line">1) <span class="string">"id"</span></span><br><span class="line">2) <span class="string">"100"</span></span><br><span class="line">3) <span class="string">"name"</span></span><br><span class="line">4) <span class="string">"Neko"</span></span><br><span class="line">5) <span class="string">"age"</span></span><br><span class="line">6) <span class="string">"66"</span></span><br><span class="line">7) <span class="string">"level"</span></span><br><span class="line">8) <span class="string">"normal"</span></span><br></pre></td></tr></table></figure>

<p>如果要移除 Hash 的某組鍵值對，需要透過 <code>HDEL</code> 。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 移除時會回傳成功移除掉的鍵值對數量</span></span><br><span class="line">127.0.0.1:6379&gt; HDEL user:100 name</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 2.4 版之後可以一次移除多個</span></span><br><span class="line">127.0.0.1:6379&gt; HDEL user:100 id age level</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure>

<p>如果 Hash 只儲存少數 Fields （一百個左右），只會佔用很小的空間，也就是說即使是一個微小的 Redis Server 也可以用來儲存百萬個 Object 而不用擔心。</p>
<h3 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h3><p>可排序的 Set ，<br>對，就這樣，連原理都蠻單純的。</p>
<p>Sorted Set 在儲存資料時會對應到一個分數（ Score ），這個分數就是拿來做排序的關鍵，排序上通常會以低 -&gt; 高。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一般的 Set</span></span><br><span class="line">127.0.0.1:6379&gt; SADD <span class="built_in">set</span>:normal <span class="string">"Neko"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可排序的 Set</span></span><br><span class="line">127.0.0.1:6379&gt; ZADD <span class="built_in">set</span>:sorted 1 <span class="string">"Neko"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<p>雖然 Set 結構不允許出現重複的元素，但是分數是可以重複的，官方對於分數重複的描述為：</p>
<blockquote>
<p>While the same element can’t be repeated in a sorted set since every element is unique, it is possible to add multiple different elements having the same score. When multiple elements have the same score, they are ordered lexicographically (they are still ordered by score as a first key, however, locally, all the elements with the same score are relatively ordered lexicographically).</p>
</blockquote>
<p>當分數一致時，會透過位元排序，也就是會將 String 視為 Byte Array 來做比對。</p>
<p>Sorted Set 除了最基礎的 Set 操作，還有許多獨自擁有的，例如說檢查某個元素當前排名 <code>ZRANK</code> ，查看指定元素目前的分數的 <code>ZSCORE</code> 等。</p>
<p>Sorted Set 有排序的關係，取出存在的元素不是 <code>ZMEMBERS</code> ，而是要改用 <code>ZRANGE</code> 。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZADD sorted 1 <span class="string">"A"</span> 2 <span class="string">"B"</span> 3 <span class="string">"C"</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此處的 0 與 -1 是表示排名，也就是第一名到最後一名全部顯示</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGE sorted 0 -1</span><br><span class="line">1) <span class="string">"A"</span></span><br><span class="line">2) <span class="string">"B"</span></span><br><span class="line">3) <span class="string">"C"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想一併知道分數，可以透過給予 WITHSCORES 參數</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGE sorted 0 -1 WITHSOCRES</span><br><span class="line">1) <span class="string">"A"</span></span><br><span class="line">2) <span class="string">"1"</span></span><br><span class="line">3) <span class="string">"B"</span></span><br><span class="line">4) <span class="string">"2"</span></span><br><span class="line">5) <span class="string">"C"</span></span><br><span class="line">6) <span class="string">"3"</span></span><br></pre></td></tr></table></figure>

<p>也可以透過可排序功能與 Pop 操作，來對任務做權重分配，例如新增會員 Score = 1 而修改會員資料 Score = 3 ，配置對應的 Worker 來取出目前等待中的任務。</p>
<p>但這樣處理時需要注意，假如進來的任務全都是權重高的，就會變成權重低的任務一直沒有處理的情況。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 透過 Block 系列的 Pop 來等待任務， MIN 指的是 Score 最小的</span></span><br><span class="line">127.0.0.1:6379&gt; BZPOPMIN events 0</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先建立一個 Sorted Set</span></span><br><span class="line">127.0.0.1:6379&gt; ZADD tasks 1 <span class="string">"create"</span> 2 <span class="string">"modify"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一樣可以監聽多個 Key ，成功收到後的訊息為三個 Key, Value, Score</span></span><br><span class="line">127.0.0.1:6379&gt; BZPOPMIN events tasks 0</span><br><span class="line">1) <span class="string">"tasks"</span></span><br><span class="line">2) <span class="string">"create"</span></span><br><span class="line">3) <span class="string">"1"</span></span><br></pre></td></tr></table></figure>

<p>Block 相關的原理請參考 <a href="#List">List</a> 末段 Block 操作。</p>
<h2 id="事務"><a href="#事務" class="headerlink" title="事務"></a>事務</h2><p>Transaction 是個術語，意思是操作是否能提供 <a href="https://zh.wikipedia.org/wiki/ACID" target="_blank" rel="noopener">ACID</a> 特性。</p>
<p>這種需求通常跟交易有關，譬如轉賬是從 A 帳戶轉移金錢到 B 帳戶，雖然看起來只需要兩步驟：</p>
<ol>
<li>A 扣錢</li>
<li>B 加錢</li>
</ol>
<p>但這涉及到操作的不安全性就沒這麼簡單。</p>
<p>好比說 A 已經扣除 1000$ ，但這時幫 B 增加 1000$ 失敗呢？會變成 A 損失 1000$ ，<br>又好比 A 扣錢失敗，但 B 卻成功增加 1000$ 。</p>
<p>Redis 提供了開始事務的 <code>MULTI</code> 與執行事務的 <code>EXEC</code> 。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先設置帳戶 A 與帳戶 B 的金額（各 5000 ）</span></span><br><span class="line">127.0.0.1:6379&gt; HSET bank:a money 5000</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; HSET bank:b money 5000</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 開始事務，此命令永遠都會回傳 OK</span></span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將帳戶 A 的金額扣除 1000 的操作加入事務中</span></span><br><span class="line">127.0.0.1:6379&gt; HINCRBY bank:a money -1000</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將帳戶 B 的金額增加 1000 的操作加入事務中</span></span><br><span class="line">127.0.0.1:6379&gt; HINCRBY bank:b money 1000</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"><span class="comment"># 執行事務中的操作，會回傳每個操作的結果</span></span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">1) (<span class="built_in">integer</span>) 4000</span><br><span class="line">2) (<span class="built_in">integer</span>) 6000</span><br></pre></td></tr></table></figure>

<p>但是與大多數人理解的事務不同的是， Redis 透過 <code>MULTI</code> / <code>EXEC</code> 的操作只能保持原子性，卻無法保持成功一同成功，失敗一同失敗，因為它不具有 Roll Back （回朔）功能。</p>
<p>換句話說依然可能存在 A 扣款 B 沒入款的情況，而 Redis 之所以不支援 Roll Back 的原因有二：</p>
<ol>
<li>Redis 命令失敗的情況只有錯誤的語法使用（且無法於 QUEUED 時發現），這種情況屬於程式邏輯錯誤，不應該出現在生產環境中</li>
<li>因為不支援 Roll Back 可以使 Redis 保持簡單與快速</li>
</ol>
<p>即使如此 Redis 也提供 <code>WATCH</code> 命令以確保與程式搭配時的 Check-And-Set （ CAS ）行為，透過 <code>WATCH</code> 可以監視指定的 Keys 是否有被更改過，如果被更改會會導致 Transaction 執行失敗。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># WATCH 必須在 MULTI 前使用</span></span><br><span class="line">127.0.0.1:6379&gt; WATCH counter</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 開始事務</span></span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把 counter 增加 1</span></span><br><span class="line">127.0.0.1:6379&gt; INCR counter</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"><span class="comment"># 執行事務，此時假設有其它 Client 修改過 counter ，回應會收到 nil</span></span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<p>很明顯是種樂觀鎖，等於對事務執行設置了前置條件，以沒人改變監視的 Keys 為依據。</p>
<p>使用 <code>WATCH</code> 時要小心，一旦碰上 <code>EXEC</code> 與 <code>DISCARD</code> 都會取消目前所有監視的 Keys ，因為前者是執行事務後者則是放棄事務。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>實際上使用 <code>MULTI</code> 時會改變 Client 端的模式，也就是轉換為事務模式。</p>
<p>當處在事務模式的 Client 只要不執行 <code>EXEC</code> 、 <code>DISCARD</code> 都不會取消事務模式，這個模式中的所有命令都會被保存在一個 Queue 內，並回應訊息 『 QUEUED 』。</p>
<p>當執行 <code>EXEC</code> 後會將 Queue 內的命令傳送給 Server ，它便會依照順序依次執行與記錄結果，最終將事務的結果回傳給 Client 。</p>
<h3 id="Lua-Script"><a href="#Lua-Script" class="headerlink" title="Lua Script"></a>Lua Script</h3><p>2.6 時 Redis 引入了 Lua 執行環境，也就是 2.6 版本之後就內建一個 Lua 的 Interpreter ，而 <a href="https://www.lua.org/" target="_blank" rel="noopener">Lua</a> 是一個極輕量的語言，它的目標是成為最容易嵌入其它語言的程式語言。</p>
<p>Redis 對於 Lua 的環境做了許多修改，以避免產生漏洞遭利用，此外也提供由 Lua 呼叫 Redis 命令的函式等。並且為了支援持久化功能， Redis 限制了 Lua 函式必須符合三點：</p>
<ol>
<li>沒有副作用</li>
<li>沒有有害的隨機性（比如隨機寫一個鍵值對）</li>
<li>同樣的輸入必得出同樣的結果</li>
</ol>
<p>Redis 保證了 Lua 的原子性，也就是當執行 Lua Script 時不會在中間執行其它 Lua Script 或 Redis Command 。</p>
<p>換句話說 Lua Script 本身就是一種 Transaction ，而且還比原本 <code>MULTI</code> / <code>EXEC</code> 更快更簡單。官方雖然短時間內不會移除舊版本的事務機制，但假使未來的使用者都傾向使用 Lua Script 來處理的話，最終可能會把舊有機制給移除。</p>
<p>我自己感覺 Lua Script 提供更多功能與靈活性，若沒特殊原因應該也會選擇 Lua ，但這邊不會再詳細介紹 Lua ，可能未來會找時間寫相關的雜學。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><a href="https://redis.io/" target="_blank" rel="noopener" title="官方網站">Redis</a></li>
<li><a href="https://draveness.me/whys-the-design-redis-single-thread" target="_blank" rel="noopener" title="面向信仰编程">为什么 Redis 选择单线程模型 · Why’s THE Design?</a></li>
<li><a href="http://redisbook.com/index.html" target="_blank" rel="noopener">Redis 设计与实现</a></li>
<li><a href="https://www.jianshu.com/p/xsMzfn" target="_blank" rel="noopener" title="简书">Redis阻塞操作实现原理</a></li>
<li><a href="http://redisdoc.com/index.html" target="_blank" rel="noopener">Redis 命令参考</a></li>
</ul>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="utterances_thread">
            <noscript>請開啟 JavaScript 功能來使用留言系統</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首頁</a></li>
         
          <li><a href="/about/">關於</a></li>
         
          <li><a href="/archives/">雜學</a></li>
         
          <li><a href="/categories/">分類</a></li>
         
          <li><a href="/search/">搜尋</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-特色？"><span class="toc-number">1.</span> <span class="toc-text">Redis 特色？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#單執行緒？"><span class="toc-number">1.1.</span> <span class="toc-text">單執行緒？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#引入多執行緒？"><span class="toc-number">1.2.</span> <span class="toc-text">引入多執行緒？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#啟動與連線"><span class="toc-number">2.</span> <span class="toc-text">啟動與連線</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#密碼"><span class="toc-number">2.1.</span> <span class="toc-text">密碼</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#設定檔"><span class="toc-number">2.2.</span> <span class="toc-text">設定檔</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用操作"><span class="toc-number">3.</span> <span class="toc-text">常用操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#String"><span class="toc-number">3.1.</span> <span class="toc-text">String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List"><span class="toc-number">3.2.</span> <span class="toc-text">List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set"><span class="toc-number">3.3.</span> <span class="toc-text">Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash"><span class="toc-number">3.4.</span> <span class="toc-text">Hash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sorted-Set"><span class="toc-number">3.5.</span> <span class="toc-text">Sorted Set</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事務"><span class="toc-number">4.</span> <span class="toc-text">事務</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原理"><span class="toc-number">4.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lua-Script"><span class="toc-number">4.2.</span> <span class="toc-text">Lua Script</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#參考資料"><span class="toc-number">5.</span> <span class="toc-text">參考資料</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://nekowarabe.github.io/2019/11/06/redis-intro-md/" target="_blank" rel="noopener"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://nekowarabe.github.io/2019/11/06/redis-intro-md/&text=淺入淺出 Redis" target="_blank" rel="noopener"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://nekowarabe.github.io/2019/11/06/redis-intro-md/&title=淺入淺出 Redis" target="_blank" rel="noopener"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://nekowarabe.github.io/2019/11/06/redis-intro-md/&is_video=false&description=淺入淺出 Redis" target="_blank" rel="noopener"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=淺入淺出 Redis&body=Check out this article: https://nekowarabe.github.io/2019/11/06/redis-intro-md/" target="_blank" rel="noopener"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://nekowarabe.github.io/2019/11/06/redis-intro-md/&title=淺入淺出 Redis" target="_blank" rel="noopener"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://nekowarabe.github.io/2019/11/06/redis-intro-md/&title=淺入淺出 Redis" target="_blank" rel="noopener"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://nekowarabe.github.io/2019/11/06/redis-intro-md/&title=淺入淺出 Redis" target="_blank" rel="noopener"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://nekowarabe.github.io/2019/11/06/redis-intro-md/&title=淺入淺出 Redis" target="_blank" rel="noopener"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://nekowarabe.github.io/2019/11/06/redis-intro-md/&name=淺入淺出 Redis&description=" target="_blank" rel="noopener"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 選單</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 段落</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 回到開頭</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2019 Nekowarabe
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">首頁</a></li>
         
          <li><a href="/about/">關於</a></li>
         
          <li><a href="/archives/">雜學</a></li>
         
          <li><a href="/categories/">分類</a></li>
         
          <li><a href="/search/">搜尋</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

    <!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<!-- clipboard -->

  <script src="/lib/clipboard/clipboard.min.js"></script>
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"複製\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight .code pre").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      target: function(trigger) {
        return trigger.nextElementSibling;
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "成功！");
      e.clearSelection();
    })
  })
  </script>

<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

<!-- Utterances Comments -->

    <script>
      (function(){
        var comment = document.getElementById("utterances_thread");
        if (comment != undefined) {
          var utterances = document.createElement('script');
          utterances.async = true;
          utterances.type = 'text/javascript'
          utterances.src = "https://utteranc.es/client.js";
          utterances.crossOrigin = "anonymous";
  
          utterances.setAttribute("theme", "photon-dark");
          utterances.setAttribute("repo", "nekowarabe/nekowarabe.github.io");
          utterances.setAttribute("issue-term", "title");

          comment.appendChild(utterances);
        }
      }());
    </script>

</body>
</html>
