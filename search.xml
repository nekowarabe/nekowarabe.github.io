<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>淺入淺出 Character Encoding</title>
      <link href="/2020/02/28/char-encode-intro/"/>
      <url>/2020/02/28/char-encode-intro/</url>
      
        <content type="html"><![CDATA[<p>編碼是撰寫程式時很難避開的部分，但出乎意料的有不少程式設計者對其一知半解。</p><p>對，包括我，所以這篇是我學習的一個紀錄與整理啦。</p><p>整個歷史大略為早期群雄割據，中文簡繁各自成一家，各地區有自己獨特的編碼，直到後來 Unicode 一統天下，結束了編碼動盪的時代。</p><h2 id="編碼"><a href="#編碼" class="headerlink" title="編碼"></a>編碼</h2><p>計算機領域的所有資料都是 Binary ，也就是 0 與 1 的組合。</p><p>那些純文本、執行檔、圖片、影片、音樂無一例外都是 Binary ，只不過 “ 解釋 “ 它們的方式不同，如同你可以用文字檔開啟圖片但會出現亂碼，其原因就在於文字編碼與圖片編碼不一致，對文字編碼來說這些 Binary 完全無法翻譯，最終變成了亂碼。</p><p><img src="pic_on_editor.jpg" alt="Notepad++ 開啟圖片"></p><h2 id="文字編碼"><a href="#文字編碼" class="headerlink" title="文字編碼"></a>文字編碼</h2><p>文字編碼原理都很單純，把 0101 等資訊對應至某個字元再顯示出來，早時國外最常使用的是 ASCII （ <strong>A</strong>merica <strong>S</strong>tandard <strong>C</strong>ode for <strong>I</strong>nformation <strong>I</strong>nterchange ）。</p><blockquote><p>其它常聽到的 ISO-8859-1 （或 Latin-1 ）是基於 ASCII 的擴充，於 0xA0 - 0xFF 範圍內加入了 96 個字母與符號</p></blockquote><p>ASCII 總共定義了 128 個字元，除去 33 個無法顯示的特殊字元外總共有 95 個字元，雖說對於英語來說足夠，但其它地區就完全不行，例如漢文。</p><p>於是各個地區的人們為了能夠使用自己的文字，紛紛創造了各自的編碼，例如台灣最常使用的 Big-5 、日本的 Shift_JIS 等，當時還有一個修改 Big-5 的 <a href="https://zh.wikipedia.org/zh-tw/Unicode%E8%A3%9C%E5%AE%8C%E8%A8%88%E7%95%AB" target="_blank" rel="noopener">Unicode 補完計畫</a>，用來填補 Big-5 的不足之處。</p><p>順帶一提日本的 Shift_JIS 最狂的就是用 「¥」取代了「\」，因此檔案路徑會像下面這樣：</p><p><img src="japan_file_path.jpg" alt="日本風格檔案路徑"></p><p>在那個時期因為各種編碼不統一造成許多麻煩，所以後來有人跳出來打算要統一世界上所有的文字編碼。</p><p>也許，應該說兩群人才對。</p><h3 id="UCS-與-Unicode"><a href="#UCS-與-Unicode" class="headerlink" title="UCS 與 Unicode"></a>UCS 與 Unicode</h3><p>UCS 全稱為 Universal Character Set ，是由 ISO 制定的統一標準，故也稱 ISO 10646 ； Unicode 則是由 Unicode 聯盟制定，此聯盟由各個國家與軟體商的代表參與。</p><p>最初時雙方各有一套自己的標準，直到在 1991 年附近時他們才覺得世界上不需要兩個不相容的統一字元集，於是開始整合彼此的標準，簡單說就是開始合作制定。</p><blockquote><p>不過有趣的是這兩個專案依然都存在而沒有整合成一個，所以各自都還是會發布新的版本</p></blockquote><p>Unicode 與 UCS 合作之後基本上雙方是相容的，但彼此還是有些<a href="https://zh.wikipedia.org/zh-tw/%E9%80%9A%E7%94%A8%E5%AD%97%E7%AC%A6%E9%9B%86#Unicode%E5%92%8CISO_10646%E7%9A%84%E5%BC%82%E5%90%8C" target="_blank" rel="noopener">異同</a>的地方，只不過現在的人應該都沒聽過 ISO 10646 吧，就連我也是因為找資料才知道的。</p><p>以下只介紹 Unicode 。</p><h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>俗稱萬國碼或統一碼，是計算機領域的字元集（ Character Set ）標準，整理世界上的文字好讓所有的計算機都可以使用一致的方式來呈現，並且連 Metadata （例如是大寫或小寫）資訊都納入其中。</p><p>Unicode 本質很單純，它替所有的文字（或稱圖形）標上唯一的編號，這樣計算機便能透過編號得知該顯示的字元。此編號被稱為 Code Point （碼點），常用 <code>U+XXXX</code> 的形式表現。</p><p>Character Set 是 Code Point 的集合，之所以稱為字元集是為了與實作編碼分開，因為 Code Point 雖然是固定的，但計算機如何用 Binary 儲存則要看實作方式，這個實作方式稱為 <strong>U</strong>nicode/UCS <strong>T</strong>ransformation <strong>F</strong>ormat ，也就是常常聽到的 UTF 。</p><blockquote><p>換句話說即使是相同的 Character Set ，若實作編碼不一樣會導致實際儲存的 Binary 不同</p></blockquote><p>Unicode 定義了 17 個<a href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84" target="_blank" rel="noopener">字元平面</a>，每個平面都有 65536 個 Code Point ，但目前只用到了第二輔助平面，其餘的都還未定。</p><p>注意第一個平面，也就是 U+0000 - U+FFFF 不被稱為第一平面而是 Basic Multilingual Plane （基本多文種平面，俗稱 BMP ），亦稱為第零平面，其餘的都稱為輔助平面：</p><ul><li>第零平面</li><li>第一輔助平面</li><li>第二輔助平面</li><li>…</li></ul><h3 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h3><p>Unicode 的實作編碼之一，顧名思義是使用 2 Byte 也就是 16 Bit 的 Binary 。</p><p>……事實上這是錯的。</p><p>UTF-16 是 UCS-2 的一個擴展， UCS-2 才是真正只用 2 Byte 編碼的實作，也就是固定長度。</p><p>做為擴展的 UTF-16 在 U+0000 - U+FFFF 區間與 USC-2 一致，但 UTF-16 好歹也是 Unicode 的實作，它必須能編碼 Unicode 全部的 Code Point 才稱職，而這只靠僅僅 2 Byte 絕對不夠，因此實際上 UTF-16 可能會是 2 Byte 或 4 Byte 的變動長度。</p><p>UTF-16 的實作利用了 BMP 中永久保留的 0xD800 - 0xDFFF 區間，該範圍不對應任何字元，所以 UTF-16 利用此區間來編碼輔助平面，也就是 U+FFFF 之後的字元，轉換方式為：</p><ol><li>Code Point 減去 0x10000 得到範圍在 0x00000 - 0xFFFFF 之間的 20 Bit</li><li>前 10 Bit 加上 0xD800 得到範圍在 0xD800 - 0xDBFF 的前導代理（ Lead surrogates ）</li><li>後 10 Bit 加上 0xDC00 得到範圍在 0xDC00 - 0xDFFF 的後尾代理（ Trail surrogates ）</li></ol><p>也就是 BMP 之外的平面都需要 20 Bit 來表示。</p><p>等等，這樣不就只需要 3 Byte 嗎？</p><p>沒這麼單純， UTF-16 為了快速辨別該字元為 2 Byte 或 4 Byte 才會在 Lead 與 Trail 各自加上不同的值，這是為了確保 Lead 與 Trail 只存在於 0xD800 - 0xDFFF 內，這樣當 UTF-16 看到 2 Byte 時就可以先確認它是不是在此範圍內，如果不是就一定是 2 Byte ；反之則為 4 Byte 。</p><p>詳細內容可以在 <a href="https://zh.wikipedia.org/wiki/UTF-16#%E4%BB%8EU+D800%E5%88%B0U+DFFF%E7%9A%84%E7%A0%81%E4%BD%8D" target="_blank" rel="noopener">Wiki</a> 內查看，寫得更為詳細。</p><h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>它並不顧名思義， UTF-8 是變動長度，以每個 Byte 為單位：</p><ul><li>1 Byte</li><li>2 Byte</li><li>3 Byte</li><li>4 Byte</li></ul><p>這樣的好處是 UTF-8 能與 ASCII 兼容，在大多舊版系統或程式可以只做少量，甚至不需修改也能正常運作。基於此因素 UTF-8 是目前最常使用的實作編碼了。</p><p>其實除了與 ASCII 兼容以外，因為 UTF-8 把常用字元都用 1 Byte 儲存，等於在無形間少掉非常多的浪費，好比說有 1000 個字的文章，如果用 UTF-16 最少要 2000 Byte ，但 UTF-8 最少可以只用 1000 Byte 來表示，這在網際網路傳遞中非常有優勢。</p><p>UTF-8 實作時會將 Code Point 切割成多個部位再依此放入 Binary ，參考下方表格：</p><table><thead><tr><th align="center">Code Point</th><th align="center">Unicode Binary</th><th align="center">UTF-8 Binary</th><th align="center">Desc</th></tr></thead><tbody><tr><td align="center">000000 - 00007F</td><td align="center">00000000 00000000 0zzzzzzz</td><td align="center">0zzzzzzz</td><td align="center">相容於 ASCII ，共 128 個字元</td></tr><tr><td align="center">000080 - 0007FF</td><td align="center">00000000 00000yyy yyzzzzzz</td><td align="center">110yyyyy 10zzzzzz</td><td align="center">第一個 Byte 以 110 開頭，後面以 10 開頭</td></tr><tr><td align="center">000800 - 00FFFF</td><td align="center">00000000 xxxxyyyy yyzzzzzz</td><td align="center">1110xxxx 10yyyyyy 10zzzzzz</td><td align="center">第一個以 1110 開頭，後面以 10 開頭</td></tr><tr><td align="center">010000 - 10FFFF</td><td align="center">000wwwxx xxxxyyyy yyzzzzzz</td><td align="center">11110www 10xxxxxx 10yyyyyy 10zzzzzz</td><td align="center">第一個以 11110 開頭，後面以 10 開頭</td></tr></tbody></table><p>明顯與 ASCII 兼容的部分都由 0 開頭，所以代表 ASCII 的相容字元永遠不會用在 0x007F 外的 Code Point ，因為只要是一個以上的 Byte 第一個 Bit 一定是 1 開頭。</p><h2 id="Endianness"><a href="#Endianness" class="headerlink" title="Endianness"></a>Endianness</h2><p>Endianness （端序），分為大端序與小端序，主要是用來區分多 Byte 的排序問題，至於單 Byte 無關的原因是大多機器都使用一致的順序處理 Bit ，所以沒有 Bit 排序問題。</p><p>假設一個 32 Bit 也就是 4 Byte 的整數型態 0x0A0B0C0D ，依據大小端序可能被存為：</p><ul><li>大端序： 0x0A 、 0x0B 、 0x0C 、 0x0D</li><li>小端序： 0x0D 、 0x0C 、 0x0B 、 0x0A</li></ul><p>這個會因為不同人有不同的選擇，有時會在檔案頭加上 BOM （ <strong>B</strong>yte <strong>O</strong>rder <strong>M</strong>ark ）來表示此檔案須以何種方式解讀。</p><blockquote><p>端序其實就是喜好問題，就像有人巧克力螺旋麵包喜歡從巧克力端吃，有人喜歡從麵包端吃一樣</p></blockquote><h3 id="UTF-16-1"><a href="#UTF-16-1" class="headerlink" title="UTF-16"></a>UTF-16</h3><p>UTF-16 需要知道端序的原因在於 UTF-16 編碼之下的字元最少由 2 Byte 構成，為了能正確解析 2 Byte 對應的字元就必須知道誰在前誰在後，所以大端序與小端序分別會在 Binary 前面加上：</p><ul><li>大端序： <code>FE EE</code></li><li>小端序： <code>EE FE</code></li></ul><blockquote><p>U+FEFF 原本在 Unicode 的定義是 “ 零寬度非換行空格 “ ，不過在 Unicode 3.2 之後只允許出現在 Binary 的開頭，等於變成端序判斷專用字元</p></blockquote><h3 id="UTF-8-1"><a href="#UTF-8-1" class="headerlink" title="UTF-8"></a>UTF-8</h3><p>UTF-8 的基本單位是 Byte ，換句話說在判別 UTF-8 的字元時根本不用管順序（永遠都只有一種順序），這也是 UTF-8 不用 BOM 的原因。</p><p>Windows 以前會在 UTF-8 的編碼檔案前頭加上 <code>EF BB BF</code> 的 BOM ，實際上這個 BOM 一點意義也沒有，反而還可能造成其它程式判斷時出錯，所以在新版 Windows 內已不再加入此 BOM 。</p><blockquote><p>而這個 BOM 其實就是 UTF-8 編碼的 “ 零寬度非換行空格 “</p></blockquote><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>Unicdoe 與 UTF 之間的關係說穿了就是介面與實作，而以前我一直都以為它們是一樣的東西。</p><p>雖然目前 UTF-8 可以說是無敵，但如果內容的字元都不屬於 BMP 平面，可能實際上 UTF-16 會比較省，畢竟中日韓等字元在 UTF-8 都是 3 Byte 以上，而除了難字以外 UTF-16 都以 2 Byte 儲存。</p><p>但這點差異看來還不值得大家改選 UTF-16 ，目前我所知道只有 JavaScript 與 Dart 這兩個語言是採用 UTF-16 。</p><p>大多數新的語言內 Character 都被定義為 32 Bit ，可是 Java 基於歷史包袱還是 16 Bit ，所以字元在 Java 內最好還是用 String 儲存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 的 char 依然使用 UTF-16 ，或是更準確的說是 UCS-2</span></span><br><span class="line"><span class="comment">// 以下都會顯示編譯錯誤 "Invalid character constant"</span></span><br><span class="line"><span class="keyword">char</span> c1 = <span class="string">'𝌆'</span>;</span><br><span class="line"><span class="keyword">char</span> c2 = <span class="string">'\u64321'</span>;</span><br></pre></td></tr></table></figure><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://zh.wikipedia.org/wiki/Unicode" target="_blank" rel="noopener">Unicode Wiki</a><br><a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F" target="_blank" rel="noopener">位元組順序 Wiki</a><br><a href="https://zh.wikipedia.org/wiki/UTF-8" target="_blank" rel="noopener">UTF-8 Wiki</a><br><a href="https://zh.wikipedia.org/wiki/UTF-16" target="_blank" rel="noopener">UTF-16 Wiki</a><br><a href="https://openhome.cc/Gossip/Encoding/UnicodeUTF.html" target="_blank" rel="noopener">Unicode 與 UTF</a></p>]]></content>
      
      
      <categories>
          
          <category> 程式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 淺入淺出 </tag>
            
            <tag> unicode </tag>
            
            <tag> utf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Meet the PHP</title>
      <link href="/2020/02/16/meet-the-php/"/>
      <url>/2020/02/16/meet-the-php/</url>
      
        <content type="html"><![CDATA[<blockquote><p><em>最後編輯於 2020-03-27</em></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2020-02-16 寫的內容因為受到當時公司的影響充滿了偏頗（完全是抱怨文），所以這次會盡可能以 PHP 這個語言給我的感覺來談談。</p><p>第一次接觸到 PHP 是在資策會，當時的結業專題因為種種原因我需要可以回應資料的 API ，但那時根本還沒教如何弄後端 API ，所以為了有資料可以在 Android 上呈現就找上了 PHP 。</p><p>直接說結論吧， PHP 跟當時所學的 Java 語法結構很不一樣而我那時也是超級菜雞，做出來的東西幾乎都是照抄網路上的範例，所以 PHP 之於我就像是被老師要求抄文言文的學生一樣，只想著『文言文他媽到底是三小，最好人討論是這樣子說話啦。』，但為了成績（ API ）還是不得不做。</p><p>我那時只覺得 PHP 真的是醜死了。</p><p>時間回到一月，我應徵上了自稱<strong>合法</strong>的博弈技術外包公司，職稱為 Java 開發工程師。</p><p>然後就開始學 PHP 了。</p><p><img src="/images/black_question.jpg" alt="黑人問號"></p><p>對，你沒看錯，不要懷疑。  </p><p>當時面試有提到公司內有用 PHP 與 Java ，而且可能會寫一些 PHP 啦⋯⋯ 但我直到最近離職前寫的全都是 PHP 耶？</p><p>抱歉離題了。</p><p>我是一個不太喜歡動態語言的人，或者說我不太喜歡規範不明確。</p><p>我認為動態語言於單人快速開發很合適，多數情況下自己的思考邏輯不會有衝突，若是已知函式輸入與輸出型態，卻還得補上型別提示、強制轉型確實令人煩躁；於多人開發則有可能導致災難，畢竟每個人的思考邏輯很難不產生衝突，所以會變成需要在程式內進行某些檢查，但這樣反而囉唆。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python 的情況，為了確保其他人不誤用所以進行型態檢查</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doSomething</span><span class="params">(arg)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(arg, str):</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">"arg must be string"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>還不如靜態語言直接註明輸入的型態：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Go 的情況，直接標示輸入值須為 string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">(arg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不過我也想過這可能是因為我沒參與過動態語言開發的大型專案，或許在那些專案中其實根本沒有這種問題存在。</p><p>總之，下面提到的點都是我不太喜歡或難以接受的部分。</p><h2 id="語法"><a href="#語法" class="headerlink" title="語法"></a>語法</h2><p>PHP 與我所熟悉的大多數語言寫法不同，當初看程式碼的時候感覺觀念被當面撕碎，加水攪拌後被潑了滿臉。</p><h3 id="操作符號"><a href="#操作符號" class="headerlink" title="操作符號"></a>操作符號</h3><p>PHP 字串串接使用 <code>.</code> 而屬性、函式存取用 <code>-&gt;</code> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python 的情況</span></span><br><span class="line">s = <span class="string">"Hello"</span> + <span class="string">" World"</span></span><br><span class="line"></span><br><span class="line">obj.something()</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PHP 的情況</span></span><br><span class="line">$s = <span class="string">"Hello"</span> . <span class="string">" World"</span>;</span><br><span class="line"></span><br><span class="line">$obj-&gt;something();</span><br></pre></td></tr></table></figure><p>一直以來碰過的語言 Java 、 Go 、 JavaScript 、 Dart 等都是用 <code>+</code> 來進行串接，而 <code>.</code> 則是用來存取屬性與函式，這讓我看程式碼的時候很痛苦，再加上公司的前輩們字串串接時都不喜歡加上空白，簡直跟天書一樣：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$url = $some_url.<span class="string">'?xxx_id='</span>.<span class="keyword">$this</span>-&gt;xxx_id;</span><br><span class="line">$buffer = $params_array[<span class="string">'no'</span>].$params_array[<span class="string">'amount'</span>].<span class="keyword">$this</span>-&gt;setting[<span class="string">'key'</span>].<span class="keyword">$this</span>-&gt;setting[<span class="string">'some_id'</span>];</span><br><span class="line">$postData[<span class="string">'Sign'</span>] = md5($postData[<span class="string">'Amount'</span>].<span class="string">'|'</span>.$postData[<span class="string">'MerId'</span>].<span class="string">'|'</span>.$postData[<span class="string">'MerOrderNo'</span>].<span class="string">'|'</span>.$postData[<span class="string">'MerOrderTime'</span>].<span class="string">'|'</span>.<span class="keyword">$this</span>-&gt;setting[<span class="string">'api_key'</span>]);</span><br></pre></td></tr></table></figure><p>雖然這種情況 <code>+</code> 也很不好看，但因為我不會誤解 <code>+</code> 的語義所以情況或許會好點。</p><p>我想對於原本學習 PHP 或有相近語法語言的人大概不會有這個問題。</p><h3 id="變數"><a href="#變數" class="headerlink" title="變數"></a>變數</h3><p>動態語言的特性之一就是變數不受型態約束：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python 的情況</span></span><br><span class="line">num = <span class="number">1</span></span><br><span class="line">num = <span class="string">"進化成字串"</span></span><br></pre></td></tr></table></figure><p>PHP 只多了個規定，要求所有的變數需以 <code>$</code> 開頭：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PHP 的情況</span></span><br><span class="line">$num = <span class="number">123</span>;</span><br><span class="line">$num = <span class="string">"就是愛錢啦"</span>;</span><br></pre></td></tr></table></figure><p>這對我來說感覺與操作符號一樣，都跟我原本的觀念衝突而導致觀看時的消耗。</p><p><code>$</code> 其實有專門的稱呼，稱為 Variable variables （可變的變數），這是什麼意思呢？</p><p>直接看個例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$a = <span class="string">"hello"</span>;</span><br><span class="line">$$a = <span class="string">"world"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"$a $&#123;$a&#125;"</span>;  <span class="comment">// 輸出： hello world</span></span><br><span class="line"><span class="keyword">echo</span> $hello;      <span class="comment">// 輸出： world</span></span><br></pre></td></tr></table></figure><p>稍微解釋一下演變過程：</p><ol><li><code>$a</code> 取出指向的值 “hello”</li><li>$ + “hello” 轉變為 <code>$hello</code></li><li><code>$hello</code> 指向值 “world”</li></ol><p><img src="/images/wait_what.gif" alt="等等，蛤？"></p><p>是個類似於 Pointer ，但又比它莫名其妙的玩意<br>我懷疑可能太容易激起同事的殺人慾望，尚未在專案中看人用過。</p><p>但你我都知道，總是有人喜歡自作聰明的使用這些功能。</p><h3 id="萬能-Array"><a href="#萬能-Array" class="headerlink" title="萬能 Array"></a>萬能 Array</h3><p>印象中的 Array （陣列）是種連續記憶體空間結構，也就是那種可以隨機存取的資料結構。</p><p>而在 PHP 內的 Array 實際上是 <strong>Sorted Hash Table</strong> （可排序雜湊表），也就是我印象中的 Map 或 Dictionary 結構。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寫法有多種，大概是因為歷史包袱的關係</span></span><br><span class="line">$arr = <span class="keyword">array</span>(<span class="string">"A"</span>, <span class="number">100</span>, <span class="number">3.14159</span>);</span><br><span class="line">$arr = [<span class="string">"A"</span>, <span class="number">100</span>, <span class="number">3.14159</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作看起來起來很正常</span></span><br><span class="line">$arr[<span class="number">0</span>]; <span class="comment">// A</span></span><br><span class="line">$arr[<span class="number">1</span>]; <span class="comment">// 100</span></span><br><span class="line">$arr[<span class="number">2</span>]; <span class="comment">// 3.14159</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但實際上只是 Key 為數字的 Map</span></span><br><span class="line">$arr = <span class="keyword">array</span>(<span class="number">0</span> =&gt; <span class="string">"A"</span>, <span class="number">1</span> =&gt; <span class="number">100</span>, <span class="number">2</span> =&gt; <span class="number">3.14159</span>);</span><br><span class="line">$arr = [</span><br><span class="line">    <span class="number">0</span> =&gt; <span class="string">"A"</span>,</span><br><span class="line">    <span class="number">1</span> =&gt; <span class="number">100</span>,</span><br><span class="line">    <span class="number">2</span> =&gt; <span class="number">3.14159</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>PHP 中 Array 很常使用，因為無論是多回傳值，多個參數都可以輕易地使用 Array 包裹起來傳遞。</p><p>要傳一堆變數？用 Array<br>回傳多個值？用 Array<br>臨時想弄個結構？用 Array  </p><p>看起來很萬用對吧？因為你也沒其它選擇了。</p><p>PHP Array 還有個詭異的語法糖：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$arr = [<span class="string">'a'</span> =&gt; <span class="string">"Apple"</span>, <span class="string">'b'</span> =&gt; <span class="string">"Banana"</span>];</span><br><span class="line"></span><br><span class="line">$arr[] = <span class="string">"Cat"</span>;  <span class="comment">// [0 =&gt; "Cat", 'a' =&gt; "Apple", 'b' =&gt; "Banana"]</span></span><br><span class="line">$arr[<span class="number">0</span>];         <span class="comment">// Cat</span></span><br><span class="line"></span><br><span class="line">$arr[<span class="number">4</span>] = <span class="string">"Four"</span>; <span class="comment">// [0 =&gt; "Cat", 4 =&gt; "Four", 'a' =&gt; "Apple", 'b' =&gt; "Banana"]</span></span><br><span class="line">$arr[] = <span class="string">"Five"</span>;  <span class="comment">// [0 =&gt; "Cat", 4 =&gt; "Four", 5 =&gt; "Five", 'a' =&gt; "Apple", 'b' =&gt; "Banana"]</span></span><br><span class="line">$arr[<span class="number">5</span>];          <span class="comment">// Five</span></span><br></pre></td></tr></table></figure><p>也就是當 Array 的 Key 不寫的時候會進行 Append （添加元素），這種語法糖我是第一次見到，老實說 PHP 有很多的工具函式，透過函式不是更具表達力嗎？</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回傳新的陣列</span></span><br><span class="line">$arr = append($arr, $new_elem);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接修改原本的</span></span><br><span class="line">append($arr, $new_elem);</span><br></pre></td></tr></table></figure><blockquote><p>PHP 的 Array 要是命名為 Map 或 Dict 之類的我都覺得還好，但是 Array 很容易誤會實際的結構</p></blockquote><h3 id="常數"><a href="#常數" class="headerlink" title="常數"></a>常數</h3><p>常數早期只能透過 <code>define(Name, Value, CaseSenstive?)</code> 這個內建函式定義，直到 5.3 之後才可以使用 const 關鍵字。</p><p>PHP 內的常數是沒有 <code>$</code> 開頭的，使用起來就跟其它語言的變數一樣，而這對我當然又是一種額外消耗，因為看到常數時會突然忘記 PHP 的變數要 <code>$</code> ；看到變數時會突然看不懂常數是啥鬼。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">"SUCCESS"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ($status == SUCCESS) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>專案內與某些套件的程式碼都是看到 <code>define()</code> 比較多，可能原因大概是 <code>define()</code> 可以透過判斷式來追加定義：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 無法這樣使用</span></span><br><span class="line"><span class="keyword">if</span> (defined(<span class="string">"SUCCESS"</span>)) &#123;</span><br><span class="line">    <span class="keyword">const</span> SUCCESS = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以追加定義</span></span><br><span class="line"><span class="keyword">if</span> (defined(<span class="string">"SUCCESS"</span>)) &#123;</span><br><span class="line">    define(<span class="string">"SUCCESS"</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一個原因或許是 <code>const</code> 只能接受靜態數值，換句話說你沒辦法用函式之類的回傳值來設定常數。</p><p>老實說這點我覺得很正常啦，常數就應該是一種固定數值才對，如果要透過函式回傳值，那不就表示可能會變動嗎，這樣還能算是常數嗎？</p><h3 id="需要修改-php-ini-來開啟函式庫"><a href="#需要修改-php-ini-來開啟函式庫" class="headerlink" title="需要修改 php.ini 來開啟函式庫"></a>需要修改 php.ini 來開啟函式庫</h3><p>這個我不確定有沒有其它解決方法，是處理專案時碰到的一個問題。</p><p>當時碰到要串接的三方 API 是使用 SOAP 協議，而 PHP 可以透過 SoapClient 類別來處理。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WSDL 是 XML 格式的服務描述檔案</span></span><br><span class="line">$client = <span class="keyword">new</span> SoapClient(<span class="string">"...?wsdl"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定要使用的 SOAP 服務名稱</span></span><br><span class="line">$res = $client-&gt;__soapCall(<span class="string">'METHOD'</span>, $params);</span><br></pre></td></tr></table></figure><p>但測試時出現錯誤說找不到 SoapClient 類別。</p><p>拜請了 Google 大神後發現要使用這個類別竟然得修改 php.ini 來啟用，我實在難以相信一個內建的函式庫竟然必須修改 PHP 設定檔才能開啟。</p><h3 id="大小寫敏感不敏感？"><a href="#大小寫敏感不敏感？" class="headerlink" title="大小寫敏感不敏感？"></a>大小寫敏感不敏感？</h3><p>PHP 中只有變數、常數是大小寫敏感的，而像是：</p><ul><li>類別</li><li>函式</li><li>關鍵字</li></ul><p>換句話說，你可以像這樣寫：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">FuncTion</span> <span class="title">justdoit</span><span class="params">($flag = tRuE)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JustDoIt();</span><br></pre></td></tr></table></figure><p>當然真的這麼做的人很少，可這真的是個匪夷所思的設計，完全不能理解。</p><p>有篇文章比較詳細的說了此設計的原因：<a href="https://zhuanlan.zhihu.com/p/26965548" target="_blank" rel="noopener">PHP黑系列之一：PHP 为什么大小写规则是如此不规则？</a></p><h3 id="多樣化的關鍵字"><a href="#多樣化的關鍵字" class="headerlink" title="多樣化的關鍵字"></a>多樣化的關鍵字</h3><p>各種各樣的關鍵字出現在 PHP 中，讓我感到困惑。</p><p>好比說 <code>include</code> 與 <code>require</code> 都可以將指定的文件給引入，類似一種複製貼上。</p><p>那麼為什麼需要兩個？因為如果是 <code>include</code> 即使對象不存在也不會出現錯誤， <code>require</code> 則會報錯，所以多數情況下都建議使用 <code>require</code> ，這就很讓人懷疑 <code>include</code> 的存在價值。</p><p>還有特殊的實體關鍵字，比如可以透過：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不論如何都會實例化當前這個類別</span></span><br><span class="line">$real_me = <span class="keyword">new</span> <span class="keyword">self</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 會實例化執行期的類別，好比說 Son 繼承後執行此段會實例化 Son</span></span><br><span class="line">$runtime_me = <span class="keyword">new</span> <span class="keyword">static</span>();</span><br></pre></td></tr></table></figure><p>其它像是為了不寫花括號而增加的 end 系列：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原本的寫法</span></span><br><span class="line"><span class="keyword">if</span> ($x == <span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"X is true"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">", real true"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"X is not true"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">", real false"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改用冒號與 end 結尾</span></span><br><span class="line"><span class="keyword">if</span> ($x == <span class="keyword">true</span>):</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"X is true"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">", real true"</span>;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"X is not true"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">", real false"</span>;</span><br><span class="line"><span class="keyword">endif</span>;</span><br></pre></td></tr></table></figure><p>不太清楚這是為了照顧多種風格的設計師還是怎樣，老樣子太多選擇容易導致困惑。</p><h3 id="官方無規範"><a href="#官方無規範" class="headerlink" title="官方無規範"></a>官方無規範</h3><p>官方理應具有一致性規範，這才不容易造成開發者的負擔。</p><p>但是 PHP 的內建函式命名你可以發現多種風格：</p><ul><li>strptime ： C 語言風格</li><li>nl2br ：縮寫風格</li><li>htmlspecialchars ：全小寫風格</li><li>json_encode ：底線區隔</li></ul><p>這來自一篇詳細解釋的文章：<a href="https://zhuanlan.zhihu.com/p/27288770" target="_blank" rel="noopener">PHP黑系列之二：PHP 为什么函数命名是如此不一致？</a></p><p>PHP 內建的函式多的誇張，所以 PHPer 最常做的事情就是去查看官方手冊，聽起來雖然很正常，但如前述 PHP 根本沒有命名脈絡可循，所以你根本不知道字串操作、加密解密都提供了哪些函式給你，還曾發生過版更替時將舊有的函式給移除的情況，再加上參數順序延續此傳統各種混亂，導致難以想像在沒手冊的狀況下寫 PHP 。</p><p>就連型態都有好幾種寫法，以下幾種都是一樣型態：</p><ul><li>int/integer</li><li>bool/boolean</li><li>float/double/real</li></ul><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>最早我是因為不喜歡動態語言的關係不太喜歡 PHP ，但是這次學習部分知識與實際撰寫後我想我可以認真的說：「我不喜歡 PHP 。」</p><p>這個語言散發著濃厚 “ 走一步算一步 “ 的氣息，也很明顯有許多<strong>致敬</strong>其它語言的部分，但重點是太多設計理念被包含在 PHP 中卻沒有被整理，變成東拼西湊弄出一個看上去還可以的成品，不過當你仔細觀察後就會發現其糟糕的內在。</p><p>當然我也不否認 PHP 在快速開發上真的很強，前公司之所以使用也是看上了 PHP 的某些特性，而我不喜歡的只是它的設計風格，如果能自己選的話 PHP 目前不會在選項內，但假使未來 PHP 狠下心決定處理掉某些糟糕的設計，那我可能就會考慮使用了。</p><p>畢竟你看 PHP 可是唯一一個寫完會變得更開心的、不容你質疑的、世界上最好的程式語言啊！</p><p><img src="before_after.jpg" alt="最棒的語言！"></p><h2 id="額外閱讀"><a href="#額外閱讀" class="headerlink" title="額外閱讀"></a>額外閱讀</h2><p><a href="https://www.zhihu.com/question/26498147" target="_blank" rel="noopener">「PHP 是最好的语言」这个梗是怎么来的？</a></p>]]></content>
      
      
      <categories>
          
          <category> 程式 </category>
          
          <category> 雜七雜八 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>淺入淺出 Float</title>
      <link href="/2020/01/15/float-intro/"/>
      <url>/2020/01/15/float-intro/</url>
      
        <content type="html"><![CDATA[<p>Float 俗稱浮點數，它相當於我們上課時學到的小數。</p><p>雖然在程式設計中是相當重要的概念，但很少有人會花心思去搞懂它，大多書籍也不會詳細解說 Float 的原理或儲存方式，更不用說為什麼浮點數計算時會出問題了。</p><h2 id="IEEE754"><a href="#IEEE754" class="headerlink" title="IEEE754"></a>IEEE754</h2><p>先介紹目前業界中最通用的標準，由 <em>William Morton Kahan</em> 的研究而制定，他也因此被稱為「浮點數之父」。</p><p>這個規範定義了四種 Float 的表示方式：</p><ol><li>單精度（ 32 bit ）</li><li>雙精度（ 64 bit ）</li><li>延伸單精度（ 43 bit 以上）</li><li>延伸雙精度（ 79 bit 以上，通常用 80 bit 實作）</li></ol><blockquote><p>IEEE 754 只有對單精度強制要求提供，其餘三種可選。不過目前大多數語言都有提供雙精度</p></blockquote><h2 id="儲存概念"><a href="#儲存概念" class="headerlink" title="儲存概念"></a>儲存概念</h2><p>在計算機的世界中萬物皆 bit ，無論整數或浮點數皆是如此。</p><p>只不過整數間無法切割， 1 ～ 10 只會有 10 個數字；小數間可以無限切割， 0 ～ 1 就擁有無限個小數，畢竟小數點後可以無限增加數字，卻對數值不會有太大的影響。</p><p>所以整數即使只單純用 bit 儲存也沒關係，例如 8 bit 可以表現出 2<sup>8</sup> 種狀態，用在整數上可以表示 0 ～ 255 ；用在小數上則連 0 ～ 1 都表現不完，所以 Float 的儲存方式註定要與 Int 不同。</p><p>如果以單精度來看 32 bit 可以表現出約 40 億種狀態，但如前面所說的這連 0 ～ 1 之間都不夠用，必須使用特殊的格式才行，再加上考慮到極大值與極小值中間往往會塞很多無意義的 0 ，它們基本上只是浪費記憶體空間，所以使用了 Scientific notation （科學記號）的概念來保存。</p><blockquote><p>科學記號是一種簡略地表示值的方法，好比說 1,234,500,000,000 -&gt; 1.2345 * 10<sup>12</sup> 或是 0.00000054321 -&gt; 5.4321 * 10<sup>-7</sup></p></blockquote><p>數值越大或越小時科學記號就越能發揮用途（節省無意義的 0 ），計算機科學中常常以 E 或 Exp （ Exponential ）來表示指數，也就是 10<sup>E</sup> ：</p><ul><li>1.2345E12</li><li>5.4321E-7</li></ul><p>在基於科學記號的概念， Float 儲存時的可以分為三個部分： <code>Sign</code> 、 <code>Exponent</code> 、 <code>Fraction</code> 。</p><h3 id="Sign"><a href="#Sign" class="headerlink" title="Sign"></a>Sign</h3><p>用來表示 Float 是為正或負，因為只有兩種狀態（ + / - ）所以不論哪個精度都只需要 1 bit 表示。</p><h3 id="Exponent"><a href="#Exponent" class="headerlink" title="Exponent"></a>Exponent</h3><p>指數的數值，此處的基數不再是 10 而是 2 ，這與 Float 的計算方式有關。</p><p>要注意它儲存的不是實際的值而是偏移後的值， Exponent 處理時會加減一個 Bias （偏移值）， Bias 的算法為 2<sup>n-1</sup> - 1 （ n 為 Exponet 的位元大小），以單精度為例的話就是 2<sup>8-1</sup> - 1 = 127 ，這麼做的原因可能是為了比較大小（排序）時的方便，因為可以直接看 bit 決定誰大。</p><blockquote><p>存有號數 0b11111101 （ -3 ） 與 0b00000011 （ 3 ） 在比較時還需考慮正負數，而無號數 0b01111100 （ 124 ）與 0b10000010 （ 130 ）直接從高位的 bit 比就知道誰更大</p></blockquote><h3 id="Fraction"><a href="#Fraction" class="headerlink" title="Fraction"></a>Fraction</h3><p>也稱為有效數，這裡是實際上數值的部分，換句話說浮點數的實際精度就是受此影響。</p><h2 id="實際儲存"><a href="#實際儲存" class="headerlink" title="實際儲存"></a>實際儲存</h2><p>Float 在儲存時一樣先經過二位元處理再儲存，以 6.375 來當例子，整數部分可以拆解為 (1 * 2<sup>2</sup>) + (1 * 2<sup>1</sup>) + (0 * 2<sup>0</sup>) ；分數部分可以拆解為 (0 * 2<sup>-1</sup>) + (1 * 2<sup>-2</sup>) + (1 * 2<sup>-3</sup>) ：</p><p><img src="float-to-binary.jpg" alt="位元轉換圖"></p><p>假設正負次方之間透過 <code>.</code> 來做隔離，那麼我們可以得到 6.375 的二位元 0b110.011 ，接著為了儲存到 Fraction 會將其轉換為科學記號形式：</p><p><img src="binary-to-fraction.jpg" alt="轉換為科學記號"></p><p>這邊利用了科學記號的概念，將 Float 給統一規格化，只不過原本是用於十進制上，所以轉化為科學記號後整數部分不會大於 10 ，但 bit 是逢二進位所以變為整數部分不會大於 2 ，這也是 Exponent 的基數為 2 的原因。</p><p>加上二位元的世界裡全部 bit 都為 0 的數就只有 0 ，其它數絕對會在裡面出現一次 1 ：</p><ul><li>0 -&gt; 0b00000000</li><li>1 -&gt; 0b00000001</li><li>7 -&gt; 0b00000111</li><li>128 -&gt; 0b10000000</li><li>⋯⋯</li></ul><p>因此非 0 的數必定可以轉換為 <code>0b1.xxx⋯⋯</code> 的形式，這樣儲存的時候還可以省略 <code>1.</code> （畢竟所有數都有）來多紀錄 1 bit 。</p><p>最終取得了 Exponent 與 Fraction 的值：</p><ul><li>Exponent = 2 + 127 = 129 （ 0b10000001 ）</li><li>Fraction = 0b10011</li></ul><p>用單精度的 Float 二位元表示：</p><table><thead><tr><th align="center">Sign</th><th align="center">Exponent</th><th align="center">Fraction</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">10000001</td><td align="center">10011000000000000000000</td></tr></tbody></table><h2 id="特殊規格"><a href="#特殊規格" class="headerlink" title="特殊規格"></a>特殊規格</h2><p>IEEE 754 也考量到許多特殊狀況，其一是展示的格式；其二是特殊值，可以參考下表：</p><table><thead><tr><th align="center">Exponent</th><th align="center">Fraction</th><th align="center">Mean</th></tr></thead><tbody><tr><td align="center">全 0</td><td align="center">全 0</td><td align="center">Zero</td></tr><tr><td align="center">非全 0</td><td align="center">不限</td><td align="center">Normalized</td></tr><tr><td align="center">全 0</td><td align="center">非全 0</td><td align="center">Denormalized</td></tr><tr><td align="center">全 1</td><td align="center">全 0</td><td align="center">Infinaty</td></tr><tr><td align="center">全 1</td><td align="center">非全 0</td><td align="center">Not a Number</td></tr></tbody></table><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>Float 實際上擁有 Normalized （正規格式）與 Denormalized （非正規格式）兩種形式，<a href="#實際儲存">前面</a>介紹的是 Normalized 。</p><p>之所有會有 Denormalized 的主要原因在於正數最小值被當初 Fraction 偷了 1 bit 影響到，如果只有 Normalized 的話單精度最小值應該是：</p><table><thead><tr><th align="center">Sign</th><th align="center">Exponent</th><th align="center">Fraction</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">00000000</td><td align="center">00000000000000000000001</td></tr></tbody></table><p>Exponent 的部分是 2<sup>0-127</sup> 約為 5.8E-39 ，而 Fraction 前方必須加 <code>1.</code> 所以是 2<sup>0</sup> + 2<sup>-23</sup> 約為 1 ，最小值算出來是 <strong>5.8E-39</strong> ，很明顯的那個 <code>1.</code> 影響了整個結果，它導致後面的 2<sup>-23</sup> 有跟沒有一樣，完全浪費掉 23 bit 。</p><p>基於此情況， IEEE 754 規定當 Exponent 為 0 但 Fraction 不為 0 時啟用 Denormalized 格式，這種格式下 Fraction 前方不用再加 <code>1.</code> 而 Exponent 則強制為 1 - Bias ，所以可以得到最小值為 2<sup>-23</sup> * 2<sup>-126</sup> 約為 <strong>1.4E-45</strong> 。</p><blockquote><p>Exponent 強制為 1 - Bias 的原因是為了與無 Denormalized 狀況下的最小值連接，理論上純 Normalized 最小值是 (2<sup>0</sup> + 2<sup>-23</sup>) * 2<sup>-127</sup> ，而 Denormalized 的最大值是 2<sup>-1</sup> * 2<sup>-126</sup> ， 2<sup>-23</sup> 影響太小可以無視，所以這兩者值近乎一樣</p></blockquote><p>不過因為多了 Denormalized 所以目前 Normalized 最小值是 Exponent 為 1 但 Fraction 為 0 ，也就是 2<sup>0</sup> * 2<sup>1-127</sup> 約 <strong>1.17E-38</strong> 。</p><h3 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h3><p>特殊值實際上就是 <code>Zero</code> 、 <code>Inf</code> 、 <code>NaN</code> 三者，而雖然那個表格中少了 Sign 這個符號位，但它是有作用的。</p><p>因此 Float 有了很詭異的 <a href="https://zh.wikipedia.org/wiki/-0" target="_blank" rel="noopener">-0</a> 值，在理論上它應該與 0 相等，而無窮數的部分比較正常，分為 +Inf 與 -Inf ，不會有語意上的問題。</p><p>NaN （非數值）這個概念最早就是來自於 IEEE 754 規範，通常指的是無法被表示的數字，好比說：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b <span class="keyword">float32</span></span><br><span class="line"></span><br><span class="line">fmt.Println(a / b)  <span class="comment">// 除以零， NaN</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">float64</span> = <span class="number">-1.0</span></span><br><span class="line"></span><br><span class="line">fmt.Println(math.Sqrt(c))  <span class="comment">// 負數開平方根， NaN</span></span><br></pre></td></tr></table></figure><p>NaN 因其名 Not a Number 並不是一個固定的數值，換句話說它與誰做比較都不相等，即使是跟自己：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b <span class="keyword">float32</span></span><br><span class="line"><span class="keyword">var</span> NaN <span class="keyword">float32</span> = a / b</span><br><span class="line"></span><br><span class="line">fmt.Println(NaN == NaN)  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>NaN 應被視為運作失敗的結果而不能跟任何數值做比對，通常來說程式語言都會提供相應的函式以供辨識。</p><h2 id="浮點數的精度失真"><a href="#浮點數的精度失真" class="headerlink" title="浮點數的精度失真"></a>浮點數的精度失真</h2><p>浮點數透過 2 的負次方來組成，但是你會發現連最簡單的 0.1 都不可能組合成功：</p><p><img src="float-precision.jpg" alt="永遠達不到的 0.1"></p><p>不管如何擴充永遠也加不到剛好 0.1 ，而 Float 的位元數量有限不可能無窮的保存下去，最終就會出現精度遺失的狀況，下面是單精度的 0.1 二位元：</p><table><thead><tr><th align="center">Sign</th><th align="center">Exponent</th><th align="center">Fraction</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">01111011</td><td align="center">10011001100110011001101</td></tr></tbody></table><p>依照前面介紹過的 Normalized 來轉換會得到 Exponent = 2<sup>123-127</sup> ； Fraction = 1.6000000238 ，兩者相乘 1.6000000238 * 2<sup>-4</sup> = <strong>0.1000000015</strong> ，即使切換成雙精度也不會改變結果，這也可以說是十進位與二進位的分數轉換天生就有問題。</p><h3 id="精度位數"><a href="#精度位數" class="headerlink" title="精度位數"></a>精度位數</h3><p>浮點數在某個範圍是精確的，但超過之後的結果就無法保證，其原因當然在 Fraction 身上。</p><p>拿單精度來說， 23 個 bit 可以表示出 8,388,608 種狀態，雖然 Float 的機制多偷 1 bit 也許該算作 24 bit ，但實際上那個 bit 等於被強制固定住，並沒有實質意義在。</p><p>總之，狀態表達雖然高達 7 位數字，但實際上能準確表達的範圍只有 6 位。這是因為在 8,388,608 之後的狀態就無法表示（好比說 9,000,000 ），所以單精度雖然某些 7 位數也可以準確表達，但因為不是每個 7 位數都可以，正常還是會說單精度的有效位數為 6 位。</p><p>有人可能無法理解為什麼 Fraction 狀態數量會與 Float 的有效位數有關，因為不是還有 Exponent 在嗎？</p><p>Exponent 只能 “ 移動 “ Fraction 的位置而已，狀態數量是固定的，好比說 2 bit 可以表現 4 種狀態，往前移動之後還是只有 4 種：</p><p><img src="exp-move-bits.jpg" alt="不論往前或往後狀態數都不變"></p><p>很明顯的移動後增加或減少的 bit （概念上的）不會影響到 Fraction 所能表示的狀態，這就是為何 Exponent 影響不到精度的原因。</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://zh.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener">IEEE 754 Wiki</a><br><a href="https://www.cnblogs.com/HDK2016/p/10506083.html" target="_blank" rel="noopener">【算法】解析IEEE 754 標準</a><br><a href="https://github.com/camsong/blog/issues/9" target="_blank" rel="noopener">JavaScript 浮点数陷阱及解法</a></p>]]></content>
      
      
      <categories>
          
          <category> 程式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 淺入淺出 </tag>
            
            <tag> float </tag>
            
            <tag> 浮點數 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>淺入淺出 JWT</title>
      <link href="/2020/01/01/jwt-intro/"/>
      <url>/2020/01/01/jwt-intro/</url>
      
        <content type="html"><![CDATA[<p>JWT （ JSON Web Token ）正如其名是一種將 JSON 作為 Token 來使用的構想，傳統的 Token 單純只為了身份驗證，但 JWT 因為是 JSON 而可以攜帶額外資訊在身上，所以適合用於分散式的系統。</p><h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>Token 中文意思是象徵、標示（中國稱令牌），是種身份驗證的機制。</p><p>大部分的系統在做與個人隱私有關的操作時往往因安全考量，要求提供帳號與密碼<br>但如果系統<strong>每次</strong>都要求使用者提供帳號與密碼的話，容易讓使用者感到麻煩。</p><p>而 Token 類似臨時的身份證，需由官方（ Server ）發給會員（ Client ）<br>當你出示 Token 給官方時就不必在提供帳號密碼等資料，因為證書提供了保證。</p><blockquote><p>Token 依據規範通常是放在 HTTP 請求的 Authorization Header ，還會加上 Bearer 前綴，比如 <code>Authorization: Bearer &lt;YOUR_TOKEN&gt;</code></p></blockquote><h2 id="JWT-不是-JWT"><a href="#JWT-不是-JWT" class="headerlink" title="JWT 不是 JWT"></a>JWT 不是 JWT</h2><p>多數人所熟知的 JWT 大多長得像：</p><p><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiTmVrbyIsImFnZSI6NjZ9.rRtZGDRTwa5jexCmki-lojh4m8plXNQnZPxI8vKh4g0</code></p><p>但實際上這是被稱為 JWS （ JSON Web Signature ）的格式。</p><p>關於 JSON 充當 Token 的規範其實共有五份：</p><ul><li><a href="https://tools.ietf.org/html/rfc7518" target="_blank" rel="noopener">JSON Web Algorithms</a></li><li><a href="https://tools.ietf.org/html/rfc7517" target="_blank" rel="noopener">JSON Web Key</a></li><li><a href="https://tools.ietf.org/html/rfc7519" target="_blank" rel="noopener">JSON Web Token</a></li><li><a href="https://tools.ietf.org/html/rfc7515" target="_blank" rel="noopener">JSON Web Signature</a></li><li><a href="https://tools.ietf.org/html/rfc7516" target="_blank" rel="noopener">JSON Web Encryption</a></li></ul><p>皆是由 IETF 的 <a href="https://datatracker.ietf.org/wg/jose/charter/" target="_blank" rel="noopener">JOSE</a> （ Javascript Object Signing and Encryption ）所制訂的 RFC 標準。</p><p>由於大多數人使用的只是 JWS 格式，而且比起 JWS 來說 JWT 更明顯地表示出是以 <strong>JSON</strong> 來當 <strong>Token</strong> 使用，再加上為了避免額外資訊帶來的困擾，介紹時通常就會省略其它不常使用的規範，久而久之對於 JWT 的印象就固定下來。</p><p>雖然沒想平反這種錯誤印象，但還是會稍微地介紹每種規格。</p><h3 id="JWA"><a href="#JWA" class="headerlink" title="JWA"></a>JWA</h3><p>JWA 定義了 JOSE 中 JWS 、 JWE 與 JWK 相關的加密演算法。</p><p>JWA 規定了幾種演算法是必須提供實作，也要求它們的代稱必須一致，而 JWS 與 JWE 之間的規範不同，以下為 JWS 演算法規範：</p><table><thead><tr><th align="center">代稱（名稱）</th><th align="center">演算法</th><th align="center">是否提供</th></tr></thead><tbody><tr><td align="center">HS256</td><td align="center">HMAC - SHA-256</td><td align="center">必須</td></tr><tr><td align="center">HS384</td><td align="center">HMAC - SHA-384</td><td align="center">可選</td></tr><tr><td align="center">HS512</td><td align="center">HMAC - SHA-512</td><td align="center">可選</td></tr><tr><td align="center">RS256</td><td align="center">RSASSA-PKCS1-v1_5 - SHA-256</td><td align="center">建議</td></tr><tr><td align="center">RS384</td><td align="center">RSASSA-PKCS1-v1_5 - SHA-384</td><td align="center">可選</td></tr><tr><td align="center">RS512</td><td align="center">RSASSA-PKCS1-v1_5 - SHA-512</td><td align="center">可選</td></tr><tr><td align="center">ES256</td><td align="center">ECDSA - P-256 ＆ SHA-256</td><td align="center">強烈建議</td></tr><tr><td align="center">ES384</td><td align="center">ECDSA - P-384 ＆ SHA-384</td><td align="center">可選</td></tr><tr><td align="center">ES512</td><td align="center">ECDSA - P-521 ＆ SHA-512</td><td align="center">可選</td></tr><tr><td align="center">PS256</td><td align="center">RSASSA-PSS - SHA-256 &amp; MGF1 - SHA-256</td><td align="center">可選</td></tr><tr><td align="center">PS384</td><td align="center">RSASSA-PSS - SHA-384 &amp; MGF1 - SHA-384</td><td align="center">可選</td></tr><tr><td align="center">PS512</td><td align="center">RSASSA-PSS - SHA-512 &amp; MGF1 - SHA-512</td><td align="center">可選</td></tr><tr><td align="center">none</td><td align="center">無</td><td align="center">可選</td></tr></tbody></table><blockquote><p>none 演算法即<strong>不防偽</strong>，正常情況是不會使用的。官方建議如果函示庫有提供此實作，應給予一個是否開啟的選項讓使用者決定允不允許 none</p></blockquote><h3 id="JWK"><a href="#JWK" class="headerlink" title="JWK"></a>JWK</h3><p>JWK 定義了加密演算法中使用到的 Key 資料結構，視為一種 JSON 即可，例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"kty"</span> : <span class="string">"EC"</span>,</span><br><span class="line">    <span class="attr">"crv"</span> : <span class="string">"P-256"</span>,</span><br><span class="line">    <span class="attr">"x"</span> : <span class="string">"f83OJ3D2xF1Bg8vub9tLe1gHMzV76e8Tus9uPHvRVEU"</span>,</span><br><span class="line">    <span class="attr">"y"</span> : <span class="string">"x_FEzRu9m36HLN_tue659LNpXW6pCyStikYjKIWI5a0"</span>,</span><br><span class="line">    <span class="attr">"kid"</span> : <span class="string">"Public key used in JWS spec Appendix A.3 example"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這個 JWK 擁有橢圓曲線加密（ ECC ）類的參數 <code>crv</code> 、 <code>x</code> 、 <code>y</code> ，並有規定的 kty （ Key Type ）與 kid （ Key ID ）屬性。</p><h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><p>JWT 定義了幾種特別的屬性，主要是給 JWS （ Payload ）與 JWE （ Ciphertext ）的額外資訊使用，但都是可選屬性，不一定得使用在 JWS 或 JWE 中。</p><p>規範中將這些屬性稱為 Claims ，以下為官方要求：</p><table><thead><tr><th align="center">屬性名稱</th><th align="center">屬性型態</th><th align="center">意思</th></tr></thead><tbody><tr><td align="center">iss</td><td align="center">String</td><td align="center">Token 發行者</td></tr><tr><td align="center">sub</td><td align="center">String</td><td align="center">主題，屬性值應為唯一</td></tr><tr><td align="center">aud</td><td align="center">String / String Array</td><td align="center">Token 接收方，最少要包含發行者否則 Token 視為無效</td></tr><tr><td align="center">exp</td><td align="center">NumberDate</td><td align="center">過期時間，超過時 Token 應視為無效</td></tr><tr><td align="center">nbf</td><td align="center">NumberDate</td><td align="center">生效時間，未到時 Token 應視為無效</td></tr><tr><td align="center">iat</td><td align="center">NumberDate</td><td align="center">發行時間，此 Token 建立的時間</td></tr><tr><td align="center">jti</td><td align="center">String</td><td align="center">JWT ID ，如果有多個發行者應確保不會有 ID 衝突</td></tr></tbody></table><blockquote><p>形態的 String 須為大小寫敏感； NumberDate 是自 <code>1970-1-1T00:00:00Z UTC</code> 開始的秒數</p></blockquote><p>除了用於額外資訊的屬性， JWT 也定義了提供給 JWS 與 JWE 使用的 JOSE Header 共用屬性，總共兩個：</p><ul><li>typ</li><li>cty</li></ul><p>這兩個都是指 <a href="https://www.iana.org/assignments/media-types/media-types.xhtml" target="_blank" rel="noopener">Media Type</a> ，差別在於 typ 指的是 Token ； cty 指的是額外資訊，當然這兩個屬性也是可選，不過除非已經知道 Token 是 JWT ，否則應提供 typ 來標示此 Token 為 JWT 。</p><blockquote><p>官方建議屬性值應去掉 <code>application/</code> 的前綴，比如 <code>application/xml</code> 應直接寫 <code>xml</code> ，如果使用大小寫不敏感的做法，官方強烈建議 jwt 應全使用大寫的 JWT</p></blockquote><h3 id="JWS"><a href="#JWS" class="headerlink" title="JWS"></a>JWS</h3><p>JWS 定義了如何簽名 Token 以防止內容資料被竄改。</p><p>表示法有 Compact （精簡） 與 JSON 格式，前者是最常用的而後者幾乎沒人用過，以下是例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* Compact</span><br><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiTmVrbyIsImFnZSI6NjZ9.rRtZGDRTwa5jexCmki-lojh4m8plXNQnZPxI8vKh4g0</span><br><span class="line"></span><br><span class="line">* JSON</span><br><span class="line">&#123;&quot;payload&quot;:&quot;eyJuYW1lIjoiTmVrbyIsImFnZSI6NjZ9&quot;,&quot;signatures&quot;:[&#123;&quot;protected&quot;:&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9&quot;,&quot;header&quot;:&#123;&quot;kid&quot;:&quot;1asE21wFR4&quot;&#125;,&quot;signature&quot;:&quot;rRtZGDRTwa5jexCmki-lojh4m8plXNQnZPxI8vKh4g0&quot;&#125;]&#125;</span><br></pre></td></tr></table></figure><p>JSON 格式就只是 JSON 轉換為字串，不知道是因為太過智障還是難看，大多數的人都會使用 Compact 。</p><p>JWS 總共由三個部分組成（皆須透過 Base64URL 來編碼）：</p><ol><li>JOSE Header</li><li>Payload</li><li>Signature</li></ol><p>JOSE Header 的部分不只 JWT 定義的屬性還有 JWS 自定義的值，其中除了 alg 以外大多是可選的故不額外介紹，想知道還有哪些<a href="https://tools.ietf.org/html/rfc7515#section-4.1" target="_blank" rel="noopener">請點此</a>。</p><blockquote><p>alg 表示此 JWS 用來簽名的加密演算法，值應為 <a href="#JWA">JWA</a> 所定義的代稱</p></blockquote><p>最簡單的 Header 看起來應為：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"typ"</span> : <span class="string">"JWT"</span>,</span><br><span class="line">    <span class="attr">"alg"</span> : <span class="string">"HS256"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 Payload 就是一個使用者自訂的 JSON ，好比說：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"id"</span> : <span class="number">1010</span>,</span><br><span class="line">    <span class="attr">"name"</span> : <span class="string">"Neko"</span>,</span><br><span class="line">    <span class="attr">"age"</span> : <span class="number">66</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Signature 是將上述的兩個部分先透過 Base64URL 編碼，接著以 <code>.</code> 組成作為演算法輸入值來計算出來的，請參考下列虛擬碼：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">header = &#123;typ: &quot;JWT&quot;, alg: &quot;HS256&quot;&#125;</span><br><span class="line">payload = &#123;id: 1010, name: &quot;Neko&quot;, age: 66&#125;</span><br><span class="line"></span><br><span class="line">header = Base64URL(header)</span><br><span class="line">payload = Base64URL(payload)</span><br><span class="line"></span><br><span class="line">input = header + &quot;.&quot; + payload</span><br><span class="line">signature = Base64URL(HMAC256(input))</span><br></pre></td></tr></table></figure><p>取得完三個部分後，透過 <code>.</code> 連接起來就會得到 JWS Compact 的 Token ：</p><p><code>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpZCI6MTAxMCwibmFtZSI6Ik5la28iLCJhZ2UiOjY2fQ.B6VQtIs8BRUIxTZHmIcR3fQ3asJlgT7bt8AfxmbP650</code></p><h3 id="JWE"><a href="#JWE" class="headerlink" title="JWE"></a>JWE</h3><p>JWS 其實很明顯可以看出資訊是公開的，畢竟只有透過 Base64URL 編碼過，相當容易就可以透過解碼取得資料內容，對於真正需要隱藏的資料，應該使用 JWE 。</p><p>JWE 由五個部分組成，所以兩個的 Token 很明顯可以看出不同：</p><ol><li>JOSE Header</li><li>Encrypted Key</li><li>Initialzation Vector</li><li>Ciphertext</li><li>Authentication Tag</li></ol><p>其實很明顯可以看出有加密用的公鑰與初始向量等資訊在其中，我並沒有仔細看 JWE 的規範所以對他真的有興趣者請參考之前提供的規範網址或是到 <a href="https://blog.othree.net/log/2016/08/13/json-web-token/" target="_blank" rel="noopener">O3noBlog - JSON Web Token</a> 。</p><h2 id="適合的情況"><a href="#適合的情況" class="headerlink" title="適合的情況"></a>適合的情況</h2><p>JWT 能夠額外攜帶資訊這點使其適合用於分布式系統，除了可以省略部分資料同步的困擾外，也能某種程度上減少 I/O 操作。</p><p>如果以修改使用者資料來看，傳統的 Token 需要做 2 次資料庫 I/O ：</p><p><img src="update-use-token.jpg" alt="傳統 Token 更新"></p><p>但如果是 JWT 則只需要做 1 次資料庫 I/O ：</p><p><img src="update-use-jwt.jpg" alt="JWT 更新"></p><p>或是基於有額外資訊這點， JWT 也相當適合用於一次性認證，比方說帳號認證、忘記密碼等。</p><h2 id="問題與建議"><a href="#問題與建議" class="headerlink" title="問題與建議"></a>問題與建議</h2><p>不過也有些很明顯的缺點，好比說 JWT 是無法被註銷，當 Server 簽發出去就只能等到過期（ exp ），沒有方法可以藉由 Server 來註銷。</p><p>此外 JWS 的 Payload 相當於公開，所以也不該在裡面放較為隱私的資訊，再考慮到 URL 長度限制或 Cookie 大小（ 4K ）， JWT 也不應該太長。</p><p>綜上所述，在使用 JWT 機制時應確保：</p><ul><li>不放敏感資料</li><li>不放常變動的資料（否則得不斷生成新的 Token ）</li><li>設置 exp 且時間不得太長</li><li>設置 jti 或 exp 來改變生成的 JWT ，極端點可以每次都換密鑰</li><li>Server 應維護 Active Token 列表或是黑名單列表來控制 JWT</li></ul><h2 id="關於一些錯誤印象"><a href="#關於一些錯誤印象" class="headerlink" title="關於一些錯誤印象"></a>關於一些錯誤印象</h2><p>很多人都覺得 JWT 拯救了世界，其實沒有。</p><p>比如說有人覺得 JWT 可以防止 CSRF （ Cross Site Request Forgery ）攻擊，但 CSRF 運作是透過 JavaScript 來運作的（當然還有手賤亂點），是 Token 就沒辦法避免攻擊。</p><p>或有人覺得 JWT 更加安全，但這也沒有，畢竟 Token 就是 Token ，況且 JWT 要偽造是有可能的，一旦 Server 端的加密密鑰被破解，對方想怎麼偽造就怎麼偽造，這樣看來還比傳統的更不安全。</p><p>最後還有人覺得可以充當 Session ，這個是最嚴重的，<strong>千萬不要把 JWT 當作 Session 使用</strong>。</p><blockquote><p>Session 是由 Server 來保存 Client 狀態物件的機制，概念是把 SessionID 交給 Client 讓它每次請求都帶上，這樣 Server 就可以辨識出 Client 當前的狀態，許多購物車就是這樣實作</p></blockquote><p>因為 Session 有幾種問題存在：</p><ol><li>額外耗費 Server 資源（創建與管理 Session 物件）</li><li>分散式系統得處理 Session 共享與傳遞</li><li>只認 ID 可能導致被盜用身份</li></ol><p>但使用 JWT 不會使情況變好甚至更糟，光是前面提過的無法銷毀就比不上 Session ，雖然也許可以透過某些機制來處理，但除非時間很多我不會建議自己研究處理機制， Session 早已行之有年，上述的問題可能早存在一堆解法，不但有經過他人的實驗也有保障，絕對比起 JWT 更好。</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://jwt.io/" target="_blank" rel="noopener">JSON Web Token</a><br><a href="https://kylinyu.win/tags/jwt" target="_blank" rel="noopener">墨冊 - JWT</a><br><a href="https://blog.othree.net/log/2016/08/13/json-web-token/" target="_blank" rel="noopener">O3noBlog - JSON Web Token</a></p>]]></content>
      
      
      <categories>
          
          <category> 程式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 淺入淺出 </tag>
            
            <tag> jwt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>狗屎爛詞 Interface</title>
      <link href="/2019/12/05/term-interface/"/>
      <url>/2019/12/05/term-interface/</url>
      
        <content type="html"><![CDATA[<p>狗屎爛詞系列專門介紹業界常使用的術語或名詞，但會以我所理解的概念去解釋，故無法保證正確性<br>若有發現不理解或錯誤的部分請留言讓我知道，以便修正更改。</p><h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><p>介面（中國稱接口）屬於程式語言的一種特性，多數靜態語言都會有。</p><p>用專業點的說法是：「介面提供了<strong>抽象化</strong>的能力，可以<strong>隱藏</strong>底層的實作讓使用者專注於行為。」</p><p>介面是人們把「合約」或「規格」這種概念引入程式語言而產生，它本來就是我們生活中一項理所當然不過的事情，舉凡生活中處處可見的插座與插頭就是基於規格而生，下圖為 2018 的世界各地插座規格。</p><p><a href="https://www.statista.com/chart/13389/the-global-guide-to-plugging-in/" target="_blank" rel="noopener" title="Infographic: The Global Guide To Plugging In  | Statista"><img src="https://infographic.statista.com/normal/chartoftheday_13389_the_global_guide_to_plugging_in_n.jpg" alt="Infographic: The Global Guide To Plugging In  | Statista" width="100%" height="auto" style="width: 100%; height: auto !important; max-width:960px;-ms-interpolation-mode: bicubic;"/></a></p><p>台灣使用 Type-A 規格插座，這代表人在台灣只要有 Type-A 的插頭你就不怕用不了電。</p><h2 id="隱藏實作？"><a href="#隱藏實作？" class="headerlink" title="隱藏實作？"></a>隱藏實作？</h2><p>Implemet （實作）指的是製造符合介面定義的產物，介面允許了我們使用產品時不必在乎產品是什麼，這也是介面最大的優點。</p><p>假如現在要去英國，你會怎麼問插座的問題？</p><ol><li>「英國使用的是哪個廠商的插座？」</li><li>「英國使用的是哪個 Type 的插座？」</li></ol><p>正常情況都會選擇 2 的方式問，畢竟誰會特地調查要玩的地方插座由哪些供應商提供？</p><p>當有了規格，就很容易去應對會變化的未知，因為產品提供者不會只有一個，有時可能高達數百個。只要可以知道未知被侷限於某種限制，那就可以將其視為已知來應對，所以只要知道英國使用 Type-G 就可以只帶 Type-G 的轉接頭。</p><p>這也是介面提供抽象化能力的意思，因為每個實作都可能會有不同之處，只不過遵照著特定規格時就代表它們一定提供規格所指定的功能，不會出現號稱實作 Type-A 的插座卻插不了 Type-A 插頭的狀況。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SocketTypeA 規格 A 的插座</span></span><br><span class="line"><span class="keyword">type</span> SocketTypeA <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 規格為 A 的插座要能接受格式為 A 的插頭</span></span><br><span class="line">    Accept(plug PlugTypeA)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Jacky 供應商的插座實作 SocketTypeA 的介面（規格）</span></span><br><span class="line"><span class="keyword">type</span> JackySocket <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(socket JackySocket)</span> <span class="title">Accept</span><span class="params">(plug PlugTypeA)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Jacky 自己的實作，與其它供應商不一定一致</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Neko 供應商的插座實作 SocketTypeA 的介面（規格）</span></span><br><span class="line"><span class="keyword">type</span> NekoSocket <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(socket NekoSocket)</span> <span class="title">Accept</span><span class="params">(plug PlugTypeA)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Neko 自己的實作，與其它供應商不一定一致</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以不同團隊之間撰寫程式合作時，其實也能透過雙方約定好的介面來工作，這樣不論哪方都不必等另一方完成才能作業，介面讓工作於未知變得可行。（當然，最終在整合時出問題的機率還是有的）</p><h3 id="缺點"><a href="#缺點" class="headerlink" title="缺點"></a>缺點</h3><p>隱藏實作還是會造成一點問題，例如下圖。</p><p><img src="plugin-example.jpg" alt="插座例子"></p><p>上面的插座雖然有差別，但都可以插入 Type-A 的插頭，只是廠商 A 可能只要 30 分鐘就能充飽；廠商 B 花 2 小時不到一半，還燒斷電路。</p><p>因為實作被隱藏了，所以使用者在真正使用前無法得知結果是什麼，換句話說你可能插入插頭後發現：</p><ul><li>沒充電</li><li>電路燒壞</li><li>冒出火花</li><li>其它</li></ul><p>因為沒人能跟我們保證實作的正確性，所以人們習慣使用知名廠商的產品，比起聽都沒聽過的多數人都會買像是 Apple 、 Google 等大公司的產品，也就是更重視實作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Adder 提供加法的介面，確保一定有 Add 功能</span></span><br><span class="line"><span class="keyword">type</span> Adder <span class="keyword">interface</span> &#123;</span><br><span class="line">    Add(a, b <span class="keyword">int</span>) <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 優秀的實作會盡可能減少使用的資源與未知問題</span></span><br><span class="line"><span class="keyword">type</span> Good <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Good)</span> <span class="title">Add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 糟糕的實作可能會有一堆詭異的狀況，甚至沒辦法保證結果會跟你預期的一致</span></span><br><span class="line"><span class="keyword">type</span> Bad <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Bad)</span> <span class="title">Add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    doAdd = <span class="literal">true</span></span><br><span class="line">    a *= <span class="number">10</span></span><br><span class="line">    b *= <span class="number">10</span></span><br><span class="line">    tmp := (a + b) / <span class="number">10</span></span><br><span class="line">    cache[a][b] = tmp</span><br><span class="line">    <span class="keyword">return</span> tmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="介面的問題"><a href="#介面的問題" class="headerlink" title="介面的問題"></a>介面的問題</h2><p>介面可以將未知的變化侷限使得人可以應對，卻也導致了一件事情 ———— 介面太過穩定。</p><p>等等，穩定難道不是一件好事嗎？</p><p>當然是好事，穩定的系統才可能長久。只不過程式絕對不可能永遠穩定，正如一個系統永遠存在著變化一樣，這時介面可能會因變化造成難以想像的劇痛。</p><p>假設未來有一種特殊的規格，可以提供最優秀的效率與最安全的防護，但與現在的所有插座、插頭都不一樣該怎麼辦？</p><p>除了將現有的所有插座、插頭全都更改或銷毀以外沒有辦法，因為當初的介面已經定死規格，所以規格發生變化就會造成大量的改動，拿台灣 2300 萬人口來計算，最少也有 5 倍以上的插座與插頭存在，這是多可怕的數字應不用言喻。</p><p>程式當然也是如此，如果有一個存在很久的介面：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Connector 必須提供 Connect 的功能</span></span><br><span class="line"><span class="keyword">type</span> Connector <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 依據給予的帳號與密碼取得連線</span></span><br><span class="line">    Connect(username <span class="keyword">string</span>, password <span class="keyword">string</span>) *Connect</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有不少廠商們都依此介面提供自己的實作，結果有一天發現介面要增加功能：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Connector 必須提供 Connect 的功能</span></span><br><span class="line"><span class="keyword">type</span> Connector <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 依據給予的帳號與密碼取得連線</span></span><br><span class="line">    Connect(username <span class="keyword">string</span>, password <span class="keyword">string</span>) *Connect</span><br><span class="line">    <span class="comment">// 將傳入的連線解除連線狀態</span></span><br><span class="line">    Disconnect(conn *Connect) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我們先不討論這種改動和不合邏輯，當介面要加入新的功能或是方法就會造成<strong>所有</strong>實作毀壞，因為介面更改後原先的實作已不再符合規格。</p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>介面是程式語言將現實的規格概念引入的特性，提供了在未知情況下依然可以作業的能力，因為實作被隱藏後就不再是重點，可以專注於介面規格上，但太過穩定的介面會難以改動。</p>]]></content>
      
      
      <categories>
          
          <category> 程式 </category>
          
          <category> 狗屎爛詞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>淺入淺出 Redis</title>
      <link href="/2019/11/06/redis-intro/"/>
      <url>/2019/11/06/redis-intro/</url>
      
        <content type="html"><![CDATA[<p>Redis 可謂是當前最知名的 In-memory Database ，常常被拿來當快取資料庫。</p><p>由 C 語言撰寫的 Redis 為鍵值對（ Key - Value ）資料庫，資料皆儲存於 Memory 所以讀寫的速度非常快，只不過這導致 Redis 若不小心關閉，所有資料會直接消失。因此它也提供可選的持久化設定，開啟的話可以在某種程度上避免資料遺失。</p><p>可以想成 Redis 是一個獨立於程式外的高級 Map （或稱 Dict ），提供許多更進階的功能。</p><h2 id="Redis-特色？"><a href="#Redis-特色？" class="headerlink" title="Redis 特色？"></a>Redis 特色？</h2><p>Redis 採用單執行緒設計，雖然 4.0 之後有選擇多執行緒，但這不改變核心概念，那就是：『操作命令皆為單執行緒處理』。</p><h3 id="單執行緒？"><a href="#單執行緒？" class="headerlink" title="單執行緒？"></a>單執行緒？</h3><p>單執行緒最大的一個特點就是不必擔心<strong>資料競爭</strong>。</p><p>假如使用了多執行緒，為了避免競爭問題勢必得加入鎖（ Lock ）的機制，有經驗的人都很清楚這個機制要妥善處理有多麻煩吧？除了每次上鎖與解鎖的額外消耗，還得注意忘了取鎖、解鎖引發的問題。</p><p>此外， Redis 性能瓶頸不是來自於 CPU ，官方的 <a href="https://redis.io/topics/faq#redis-is-single-threaded-how-can-i-exploit-multiple-cpu--cores" target="_blank" rel="noopener" title="Redis is single threaded">FQA</a> 也說了：</p><blockquote><p>It’s not very frequent that CPU becomes your bottleneck with Redis, as usually Redis is either memory or network bound. For instance, using pipelining Redis running on an average Linux system can deliver even 1 million requests per second, so if your application mainly uses O(N) or O(log(N)) commands, it is hardly going to use too much CPU.</p></blockquote><p>即使在普通的 Linux 系統上啟動 Redis ，也能在 1sec 的時間內服務 1,000,000 個請求。</p><h3 id="引入多執行緒？"><a href="#引入多執行緒？" class="headerlink" title="引入多執行緒？"></a>引入多執行緒？</h3><p>確實在 4.0 版本中 Redis 引入多執行緒，這是因為後續加入了可異步處理的刪除操作。</p><table><thead><tr><th align="left">Async</th><th align="left">Sync</th></tr></thead><tbody><tr><td align="left">UNLINK</td><td align="left">DEL</td></tr><tr><td align="left">FLUSHALL ASYNC</td><td align="left">FLUSHALL</td></tr><tr><td align="left">FLUSHDB ASYNC</td><td align="left">FLUSHDB</td></tr></tbody></table><p>要刪除容量不大（ Memory Size ）的鍵值對不會花太多功夫，所以就算單執行緒<strong>同步地</strong>刪除也不太會阻塞到其它操作。</p><p>不過 Redis 也可能有巨型資料存在，動輒十幾 MB 或是幾百 MB 都可能，而這種龐大的資料不可能短時間內處理完，這樣會導致其它操作卡住。</p><p>異步版本的刪除命令，原理是先將 Key 給移除，而實際上 Value 的刪除則是透過其它執行緒來執行，這樣就可以在刪除大型資料時也不導致 Redis 卡住。</p><p>至於在 6.0 的多執行緒 I/O 主要是用來處理網路的讀寫，也就是實際上命令的執行依然維持在單執行緒。</p><h2 id="啟動與連線"><a href="#啟動與連線" class="headerlink" title="啟動與連線"></a>啟動與連線</h2><p>Redis 服務啟動時沒有傳入任何參數的話，預設會監聽 Port 6379 ，可以透過 <code>--port</code> 或是指定設定檔，但是設定檔要自己建立。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 透過參數指定 Port</span></span><br><span class="line">$ redis-server --port 6666</span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過設定檔</span></span><br><span class="line">$ redis-server redis.conf</span><br></pre></td></tr></table></figure><p>之後就可以藉由 redis-cli 來連線到 Redis ，直接執行時如果沒設定參數，會連向本地的 6379 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>要遠端連接需要透過 <code>-h</code> 指定 Host ； <code>-p</code> 指定 Port 。</p><h3 id="密碼"><a href="#密碼" class="headerlink" title="密碼"></a>密碼</h3><p>Redis 是可以設置密碼的，有兩種方式，分別是設定檔與操作命令。</p><p>設定檔只需要加入 <code>requirepass PASSWORD</code> 這段訊息，並在 Redis Server 啟動時指定使用該設定檔即可。</p><p>透過命令的話先連線至已啟動的 Redis Server ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先連線到 Redis Server</span></span><br><span class="line">$ redis-cli</span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的命令可以看目前密碼是否有設置</span></span><br><span class="line">127.0.0.1:6379&gt; CONFIG GET requirepass</span><br><span class="line">1) <span class="string">"requirepass"</span></span><br><span class="line">2) <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過 SET 來設置密碼（ requirepass ）</span></span><br><span class="line">127.0.0.1:6379&gt; CONFIG SET requirepass <span class="string">"PASSWORD"</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>當看到 OK 後如果在執行一次 GET 會出現錯誤訊息「 (error) NOAUTH Authentication required. 」，這樣就得透過認證命令來獲取權限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; AUTH <span class="string">"PASSWORD"</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>除了透過這種方式登入有設定密碼的 Redis ，也可以在執行 redis-cli 時透過 <code>-a</code> 來傳遞密碼：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -a PASSWORD</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>但這種方式並不推薦，原因在於 <code>-a</code> 送出的密碼會是明文傳遞，很容易被他人攔截到，所以大多情況還是建議使用 <code>AUTH</code> 命令來驗證。</p><blockquote><p>注意要移除密碼不是透過 <code>DEL</code> ，而是要透過 <code>SET</code> 將密碼設定為 “” （空字串）</p></blockquote><h3 id="設定檔"><a href="#設定檔" class="headerlink" title="設定檔"></a>設定檔</h3><p>Redis 啟動時都會使用一組設定檔，沒有指定時會使用預設值。</p><p>設定檔可以指定多種不同的資訊，如前述的密碼，或是開啟主從式架構的關係等，如果想知道當前的設定檔資訊，可以透過前綴 <code>CONFIG</code> 搭配 <code>GET</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 回傳的訊息中，奇數為設定的名稱；偶數為設定的值</span></span><br><span class="line">127.0.0.1:6379&gt; CONFIG GET *</span><br><span class="line">1) <span class="string">"dbfilename"</span></span><br><span class="line">2) <span class="string">"dump.rdb"</span></span><br><span class="line">3) <span class="string">"requirepass"</span></span><br><span class="line">4) <span class="string">""</span></span><br><span class="line">...</span><br><span class="line">213) <span class="string">"bind"</span></span><br><span class="line">214) <span class="string">""</span></span><br></pre></td></tr></table></figure><p>另外也能用 <code>INFO</code> 命令可以看當前 Redis 的相關資訊。</p><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><p>說起 Map 結構，其實核心操作不過就是 Get 與 Set 而已。</p><p>Redis 支援多種資料型態：</p><ol><li>String</li><li>List</li><li>Set</li><li>Hash</li><li>Sorted Set</li><li>Bitmap</li><li>HyperLogLog</li></ol><p>後面有兩個詭異的型態，但這邊先不介紹，通常我們會使用的應該只有前幾個，大部分的命令可以<a href="https://redis.io/commands" target="_blank" rel="noopener" title="Redis Commands">到此</a>查詢。</p><blockquote><p>上列表中沒有出現 Number / Numeric 型態，因為 Redis 會把值都會轉換成 String 儲存，因此部份與數字相關的操作（ <code>INCR</code> 、 <code>DECR</code> ），實際上都是先將其轉換為數字才處理</p></blockquote><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>可以透過 <code>SET</code> 設置指定 Key 與其相對的 Value （型態為 String ），也能藉由 <code>GET</code> 取出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 設定 name - Neko 鍵值對</span></span><br><span class="line">127.0.0.1:6379&gt; SET name <span class="string">"Neko"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 藉由 Key 取出對應的 Value</span></span><br><span class="line">127.0.0.1:6379&gt; GET name</span><br><span class="line"><span class="string">"Neko"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 讀取不存在的 Key 會收到 nil</span></span><br><span class="line">127.0.0.1:6379&gt; GET neko</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p>如果值不包含空白，可以不加入雙引號：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SET name Neko</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; GET name</span><br><span class="line">&quot;Neko&quot;</span><br></pre></td></tr></table></figure><p>當儲存的 Value 是可以被轉換成數字（ Integer 、 Float ），就可以使用數字相關的操作，好比說加減的 <code>INCR</code> 與 <code>DECR</code> （各自等於 <code>INCRBY 1</code> 與 <code>DECRBY 1</code> ）。</p><blockquote><p>如果增減的值屬於浮點數請改用 <code>INCRBYFLOAT</code> ，否則會出現型態轉換錯誤</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 設置數字的 Value</span></span><br><span class="line">127.0.0.1:6379&gt; SET num <span class="string">"1"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過 INCR 加一，會回傳加完後的值</span></span><br><span class="line">127.0.0.1:6379&gt; INCR num</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 想指定增加的值就需使用 INCRBY</span></span><br><span class="line">127.0.0.1:6379&gt; INCRBY num 3</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 減的操作相似，不用加上負號</span></span><br><span class="line">127.0.0.1:6379&gt; DECRBY num 3</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增減的值如果是 Float 就需用 INCRBYFLOAT （不論加或減）</span></span><br><span class="line">127.0.0.1:6379&gt; INCRBYFLOAT num 0.5</span><br><span class="line"><span class="string">"2.5"</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; INCRBYFLOAT num -0.5</span><br><span class="line"><span class="string">"2"</span></span><br></pre></td></tr></table></figure><p>注意，對於 <code>INCRBY</code> 與 <code>DECRBY</code> 命令的回傳值都會做 Integer 轉換，所以假使你的值為 Float ，那麼回傳值可能會出現錯誤「 (error) ERR value is not an integer or out of range 」。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SET f 0.5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 這種情況下會視為失敗，會保持原本的值</span></span><br><span class="line">127.0.0.1:6379&gt; INCR f</span><br><span class="line">(error) ERR value is not an <span class="built_in">integer</span> or out of range</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; GET f</span><br><span class="line"><span class="string">"0.5"</span></span><br></pre></td></tr></table></figure><p>也有命令可以一次存取多個鍵值對，這些命令前方會多 M （ <code>MSET</code> 、 <code>MGET</code> ），用法基本上是沒有差別的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 透過空白隔離多個鍵值對</span></span><br><span class="line">127.0.0.1:6379&gt; MSET name <span class="string">"Doge"</span> age <span class="string">"66"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取出時會依照輸入 Key 的順序</span></span><br><span class="line">127.0.0.1:6379&gt; MGET age name</span><br><span class="line">1) <span class="string">"66"</span></span><br><span class="line">2) <span class="string">"Doge"</span></span><br></pre></td></tr></table></figure><p>Redis 在設值時有提供多種方式，可以在特定條件下才設值。<br>原本這些命令都被拆分開來，但在 2.6.12 時可以透過 <code>SET</code> 參數方式使用。</p><table><thead><tr><th align="left">Command</th><th align="left">Option</th><th align="center">Desc</th></tr></thead><tbody><tr><td align="left">SETEX</td><td align="left">EX</td><td align="center">指定過期時間，到了以後會移除（ second ）</td></tr><tr><td align="left">PSETEX</td><td align="left">PX</td><td align="center">指定過期時間，到了以後會移除（ millisecond ）</td></tr><tr><td align="left">SETNX</td><td align="left">NX</td><td align="center">當 Key 不存在時才設值</td></tr><tr><td align="left">-</td><td align="left">XX</td><td align="center">當 Key 存在時才設值</td></tr></tbody></table><p>透過參數形式的好處是可以混合多種 Option ，好比說我希望在沒有 Key 時設值，且這個值有效時間只有 10 秒，這種情況只能透過 Option 的方式設定。</p><blockquote><p>官方已不再建議使用 Command 形式，上面的三個命令可能會在未來被移除</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下方兩種方式結果是一樣的</span></span><br><span class="line">127.0.0.1:6379&gt; SET secret <span class="string">"abc123"</span> EX 10</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SETEX secret 10 <span class="string">"abc123"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 混合 Option 當 Key 不存在才設值且有效時間為 5 秒</span></span><br><span class="line">127.0.0.1:6379&gt; SET secret <span class="string">"abc123"</span> NX EX 5</span><br></pre></td></tr></table></figure><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>Redis 的 List 是單純的 String List ，使用時可以將元素放入頭或尾。<br>其實就是 Linked List ，據官方的說明可以儲存 2^32 - 1 個元素（ 4,294,967,295 ）。</p><p>增加元素時會確認是否已存在 List ，不存在時會自動建立，而透過命令移除元素時如果會使 List 為空，則會移除該 Key 。</p><blockquote><p>意思是如果 List 被清空，那麼等於此 Key 沒被設置過</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 元素放入的方式有左與右（ LPUSH 、 RPUSH ），並回傳當前 List 長度</span></span><br><span class="line">127.0.0.1:6379&gt; LPUSH nums <span class="string">"10"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; RPUSH nums <span class="string">"20"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># LRANGE 可以取出指定 Key 的 Start Index 到 End Index 的值</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE nums 0 -1</span><br><span class="line">1) <span class="string">"10"</span></span><br><span class="line">2) <span class="string">"20"</span></span><br></pre></td></tr></table></figure><p>Index 的部分支援逆向，所以例子的 -1 意思是倒數最後一個元素，整條命令就是取出 List 上所有元素。</p><p>取出元素可以基於 Index 或是如 Queue 一樣在取值時會將其移出 List ，前者就如同程式語言內常用的 List[Index] 操作；後者則是 Queue 的 Pop 操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下會建立出 [10, 20, 30] 的陣列</span></span><br><span class="line">127.0.0.1:6379&gt; RPUSH nums <span class="string">"10"</span> <span class="string">"20"</span> <span class="string">"30"</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基於 Index 取值，但不會移出 List</span></span><br><span class="line">127.0.0.1:6379&gt; LINDEX nums 0</span><br><span class="line"><span class="string">"10"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 從左取出第一個元素，並移出 List</span></span><br><span class="line">127.0.0.1:6379&gt; LPOP nums</span><br><span class="line"><span class="string">"10"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 從右取出第一個元素，並移出 List</span></span><br><span class="line">127.0.0.1:6379&gt; RPOP nums</span><br><span class="line"><span class="string">"30"</span></span><br></pre></td></tr></table></figure><p>Pop 相關的操作還有提供 Block 版本，表示如果 Pop 的對象沒有任何元素可以取出，那麼連線將 Block 直到有元素可以回傳或超時。</p><p>命令需給予超時時限（ second ），但如果給 0 則表示無限制。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果 nums 左有元素可以取出，則效果同 LPOP 否則會卡在此處直到有元素可回傳或 30 秒後</span></span><br><span class="line">127.0.0.1:6379&gt; BLPOP nums 30</span><br><span class="line">(nil)</span><br><span class="line">(30.9s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有元素的情況就如同一般 POP</span></span><br><span class="line">127.0.0.1:6379&gt; LPUSH nums <span class="string">"1"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; BLPOP nums 30</span><br><span class="line"><span class="string">"1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以一次 Block 監聽多個 Key 有沒有元素，會回傳第一個不為空的元素</span></span><br><span class="line">127.0.0.1:6379&gt; BLPOP nums names ages 30</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>單執行緒的 Redis 在處理 Block 時，會透過 Dict 來儲存 Key 與等待者的資訊，好比說 ClientID 。並在每次處理命令時都檢查是否有元素可以提供。</p><p>當然如果是這樣會導致每次跑命令都浪費時間，所以 Redis 利用兩個 Dict 來記錄，名稱分別為 <strong>blocking_keys</strong> 與 <strong>ready_keys</strong> 。</p><ul><li>blocking_keys<br>  為 Key : List&lt;Client&gt; 的 Dict ，記錄著有人等待的 Key 與等待者相關訊息。</li><li>ready_keys<br>  當 Push 的 Key 為空 List 時會檢查該 Key 是否存在於 blocking_keys 內，有的話會將相關訊息放入 ready_keys ，也是每次 Redis 處理命令時會檢查的對象。</li></ul><p>所以實際上只有在處理 Push 相關訊息時才會檢查 Block 名單，如果該 key 剛好在 Block 名單中就透過 Ready 名單通知 Server 與 Client 。</p><blockquote><p>在 <code>MULTI</code> / <code>EXEC</code> 中使用 Block 的命令，會因為交易原子性問題馬上回應，效用等同於非 Block 操作</p></blockquote><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Redis 的 Set 為無序的 String 集合，據官方所說可儲存的數量與 List 同樣為 2^32 - 1 個（ 4,294,967,295 ）。</p><p>與常見的 Set 結構一樣，內部的元素是不允許重複的。</p><p>透過 <code>SADD</code> 可以替 Set 放入元素，要是想確認某個元素是否存在於 Set 需要透過 <code>SISMEMBER</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SADD 可以一次放入多樣值，回傳 Set 操作後的元素數量</span></span><br><span class="line">127.0.0.1:6379&gt; SADD unique <span class="string">"Neko"</span> <span class="string">"Doge"</span> <span class="string">"Neko"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢查指定元素是否存在，回傳 Integer 存在為 1 ；不存在為 0</span></span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER unique <span class="string">"Neko"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER unique <span class="string">"Jacky"</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><p>移除 Set 內的資料可以透過 <code>SPOP</code> 與 <code>SREM</code> ，<br>但前者是<strong>隨機地</strong>移除指定 Set 的元素，後者才可以指定移除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SADD unique <span class="string">"A"</span> <span class="string">"B"</span> <span class="string">"C"</span> <span class="string">"D"</span> <span class="string">"E"</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 隨機移除兩個元素，數量省略時預設為 1</span></span><br><span class="line">127.0.0.1:6379&gt; SPOP unique 2</span><br><span class="line">1) <span class="string">"B"</span></span><br><span class="line">2) <span class="string">"D"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除指定元素， 2.4 之後可以一次移除多個，會回傳被移除的數量</span></span><br><span class="line">127.0.0.1:6379&gt; SREM unique <span class="string">"A"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假使移除不存在的元素也可以，但不會包含在移除數量中</span></span><br><span class="line">127.0.0.1:6379&gt; SREM unique <span class="string">"A"</span> <span class="string">"B"</span> <span class="string">"C"</span> <span class="string">"D"</span> <span class="string">"E"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure><p>如果想確認 Set 目前的數量可以用 <code>SCARD</code> ，不過想知道目前裡面所有的元素內容就得透過 <code>SMEMBERS</code> 。後者的速度比較慢，以時間複雜度來說前者為 O(1) 後者為 O(N) 。</p><p>Set 本身也有比較進階的操作，好比說交集（ <code>SINTER</code> ）、聯集（ <code>SUNION</code> ）、差集（ <code>SDIFF</code> ）等，除了聯集以外，另外兩個都是以第一個 Set 為基礎去處理，而非把每個 Set 都視為平等。</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>Hash 就是鍵值皆為 String 的 Map 結構，也因此很適合用來模擬 Object 。當然，據官方所說 Hash 同樣可以儲存 2^32 - 1 組鍵值對。</p><p>以一個 JSON 物件來當例子可以更好理解 Hash 如何模擬物件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"Neko"</span>,</span><br><span class="line">    <span class="attr">"age"</span>: <span class="number">66</span>,</span><br><span class="line">    <span class="attr">"level"</span>: <span class="string">"normal"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述為擁有編號、名稱、等級等資訊的 User 物件，透過 <code>HSET</code> 來設置這個物件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 設置成功後會回傳成功加入的鍵值對數量</span></span><br><span class="line">127.0.0.1:6379&gt; HSET user:100 id 100</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.0 之後 HSET 允許一次設定多組鍵值對</span></span><br><span class="line">127.0.0.1:6379&gt; HSET user:100 name <span class="string">"Neko"</span> age 66 level <span class="string">"normal"</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.0 之前要設定多組得透過 HMSET</span></span><br><span class="line">127.0.0.1:6379&gt; HMSET user:100 name <span class="string">"Neko"</span> age 66 level <span class="string">"normal"</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><p>回傳的值是被<strong>新加入</strong>的鍵值對數量，換句話說修改是不包含在內的，這種情況會收到 0 。</p><blockquote><p>Redis 建議命名 Key 時如果有不同區段訊息，應該透過 <code>:</code> 來區隔而不是 <code>_</code></p></blockquote><p>雖說上面的例子是模擬 Object ，但是身為 Map 結構該有的操作都沒少，例如讀取某個 Key 對應的 Value ，或取出目前所有 Key 、 Value 等命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 單獨取用某個 Key 的值</span></span><br><span class="line">127.0.0.1:6379&gt; HGET user:100 name</span><br><span class="line"><span class="string">"Neko"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只取出對象目前所有的 Key</span></span><br><span class="line">127.0.0.1:6379&gt; HKEYS user:100</span><br><span class="line">1) <span class="string">"id"</span></span><br><span class="line">2) <span class="string">"name"</span></span><br><span class="line">3) <span class="string">"age"</span></span><br><span class="line">4) <span class="string">"level"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只取出對象目前所有的 Value</span></span><br><span class="line">127.0.0.1:6379&gt; HVALS user:100</span><br><span class="line">1) <span class="string">"100"</span></span><br><span class="line">2) <span class="string">"Neko"</span></span><br><span class="line">3) <span class="string">"66"</span></span><br><span class="line">4) <span class="string">"normal"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把全部鍵值對都取出來，奇數為 Key ；偶數為 Value</span></span><br><span class="line">127.0.0.1:6379&gt; GETALL user:100</span><br><span class="line">1) <span class="string">"id"</span></span><br><span class="line">2) <span class="string">"100"</span></span><br><span class="line">3) <span class="string">"name"</span></span><br><span class="line">4) <span class="string">"Neko"</span></span><br><span class="line">5) <span class="string">"age"</span></span><br><span class="line">6) <span class="string">"66"</span></span><br><span class="line">7) <span class="string">"level"</span></span><br><span class="line">8) <span class="string">"normal"</span></span><br></pre></td></tr></table></figure><p>如果要移除 Hash 的某組鍵值對，需要透過 <code>HDEL</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 移除時會回傳成功移除掉的鍵值對數量</span></span><br><span class="line">127.0.0.1:6379&gt; HDEL user:100 name</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 2.4 版之後可以一次移除多個</span></span><br><span class="line">127.0.0.1:6379&gt; HDEL user:100 id age level</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><p>如果 Hash 只儲存少數 Fields （一百個左右），只會佔用很小的空間，也就是說即使是一個微小的 Redis Server 也可以用來儲存百萬個 Object 而不用擔心。</p><h3 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h3><p>可排序的 Set ，<br>對，就這樣，連原理都蠻單純的。</p><p>Sorted Set 在儲存資料時會對應到一個分數（ Score ），這個分數就是拿來做排序的關鍵，排序上通常會以低 -&gt; 高。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一般的 Set</span></span><br><span class="line">127.0.0.1:6379&gt; SADD <span class="built_in">set</span>:normal <span class="string">"Neko"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可排序的 Set</span></span><br><span class="line">127.0.0.1:6379&gt; ZADD <span class="built_in">set</span>:sorted 1 <span class="string">"Neko"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><p>雖然 Set 結構不允許出現重複的元素，但是分數是可以重複的，官方對於分數重複的描述為：</p><blockquote><p>While the same element can’t be repeated in a sorted set since every element is unique, it is possible to add multiple different elements having the same score. When multiple elements have the same score, they are ordered lexicographically (they are still ordered by score as a first key, however, locally, all the elements with the same score are relatively ordered lexicographically).</p></blockquote><p>當分數一致時，會透過位元排序，也就是會將 String 視為 Byte Array 來做比對。</p><p>Sorted Set 除了最基礎的 Set 操作，還有許多獨自擁有的，例如說檢查某個元素當前排名 <code>ZRANK</code> ，查看指定元素目前的分數的 <code>ZSCORE</code> 等。</p><p>Sorted Set 有排序的關係，取出存在的元素不是 <code>ZMEMBERS</code> ，而是要改用 <code>ZRANGE</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZADD sorted 1 <span class="string">"A"</span> 2 <span class="string">"B"</span> 3 <span class="string">"C"</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此處的 0 與 -1 是表示排名，也就是第一名到最後一名全部顯示</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGE sorted 0 -1</span><br><span class="line">1) <span class="string">"A"</span></span><br><span class="line">2) <span class="string">"B"</span></span><br><span class="line">3) <span class="string">"C"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想一併知道分數，可以透過給予 WITHSCORES 參數</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGE sorted 0 -1 WITHSOCRES</span><br><span class="line">1) <span class="string">"A"</span></span><br><span class="line">2) <span class="string">"1"</span></span><br><span class="line">3) <span class="string">"B"</span></span><br><span class="line">4) <span class="string">"2"</span></span><br><span class="line">5) <span class="string">"C"</span></span><br><span class="line">6) <span class="string">"3"</span></span><br></pre></td></tr></table></figure><p>也可以透過可排序功能與 Pop 操作，來對任務做權重分配，例如新增會員 Score = 1 而修改會員資料 Score = 3 ，配置對應的 Worker 來取出目前等待中的任務。</p><p>但這樣處理時需要注意，假如進來的任務全都是權重高的，就會變成權重低的任務一直沒有處理的情況。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 透過 Block 系列的 Pop 來等待任務， MIN 指的是 Score 最小的</span></span><br><span class="line">127.0.0.1:6379&gt; BZPOPMIN events 0</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先建立一個 Sorted Set</span></span><br><span class="line">127.0.0.1:6379&gt; ZADD tasks 1 <span class="string">"create"</span> 2 <span class="string">"modify"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一樣可以監聽多個 Key ，成功收到後的訊息為三個 Key, Value, Score</span></span><br><span class="line">127.0.0.1:6379&gt; BZPOPMIN events tasks 0</span><br><span class="line">1) <span class="string">"tasks"</span></span><br><span class="line">2) <span class="string">"create"</span></span><br><span class="line">3) <span class="string">"1"</span></span><br></pre></td></tr></table></figure><p>Block 相關的原理請參考 <a href="#List">List</a> 末段 Block 操作。</p><h2 id="事務"><a href="#事務" class="headerlink" title="事務"></a>事務</h2><p>Transaction 是個術語，意思是操作是否能提供 <a href="https://zh.wikipedia.org/wiki/ACID" target="_blank" rel="noopener">ACID</a> 特性。</p><p>這種需求通常跟交易有關，譬如轉賬是從 A 帳戶轉移金錢到 B 帳戶，雖然看起來只需要兩步驟：</p><ol><li>A 扣錢</li><li>B 加錢</li></ol><p>但這涉及到操作的不安全性就沒這麼簡單。</p><p>好比說 A 已經扣除 1000$ ，但這時幫 B 增加 1000$ 失敗呢？會變成 A 損失 1000$ ，<br>又好比 A 扣錢失敗，但 B 卻成功增加 1000$ 。</p><p>Redis 提供了開始事務的 <code>MULTI</code> 與執行事務的 <code>EXEC</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先設置帳戶 A 與帳戶 B 的金額（各 5000 ）</span></span><br><span class="line">127.0.0.1:6379&gt; HSET bank:a money 5000</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; HSET bank:b money 5000</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 開始事務，此命令永遠都會回傳 OK</span></span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將帳戶 A 的金額扣除 1000 的操作加入事務中</span></span><br><span class="line">127.0.0.1:6379&gt; HINCRBY bank:a money -1000</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將帳戶 B 的金額增加 1000 的操作加入事務中</span></span><br><span class="line">127.0.0.1:6379&gt; HINCRBY bank:b money 1000</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"><span class="comment"># 執行事務中的操作，會回傳每個操作的結果</span></span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">1) (<span class="built_in">integer</span>) 4000</span><br><span class="line">2) (<span class="built_in">integer</span>) 6000</span><br></pre></td></tr></table></figure><p>但是與大多數人理解的事務不同的是， Redis 透過 <code>MULTI</code> / <code>EXEC</code> 的操作只能保持原子性，卻無法保持成功一同成功，失敗一同失敗，因為它不具有 Roll Back （回朔）功能。</p><p>換句話說依然可能存在 A 扣款 B 沒入款的情況，而 Redis 之所以不支援 Roll Back 的原因有二：</p><ol><li>Redis 命令失敗的情況只有錯誤的語法使用（且無法於 QUEUED 時發現），這種情況屬於程式邏輯錯誤，不應該出現在生產環境中</li><li>因為不支援 Roll Back 可以使 Redis 保持簡單與快速</li></ol><p>即使如此 Redis 也提供 <code>WATCH</code> 命令以確保與程式搭配時的 Check-And-Set （ CAS ）行為，透過 <code>WATCH</code> 可以監視指定的 Keys 是否有被更改過，如果被更改會會導致 Transaction 執行失敗。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># WATCH 必須在 MULTI 前使用</span></span><br><span class="line">127.0.0.1:6379&gt; WATCH counter</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 開始事務</span></span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把 counter 增加 1</span></span><br><span class="line">127.0.0.1:6379&gt; INCR counter</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"><span class="comment"># 執行事務，此時假設有其它 Client 修改過 counter ，回應會收到 nil</span></span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p>很明顯是種樂觀鎖，等於對事務執行設置了前置條件，以沒人改變監視的 Keys 為依據。</p><p>使用 <code>WATCH</code> 時要小心，一旦碰上 <code>EXEC</code> 與 <code>DISCARD</code> 都會取消目前所有監視的 Keys ，因為前者是執行事務後者則是放棄事務。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>實際上使用 <code>MULTI</code> 時會改變 Client 端的模式，也就是轉換為事務模式。</p><p>當處在事務模式的 Client 只要不執行 <code>EXEC</code> 、 <code>DISCARD</code> 都不會取消事務模式，這個模式中的所有命令都會被保存在一個 Queue 內，並回應訊息 『 QUEUED 』。</p><p>當執行 <code>EXEC</code> 後會將 Queue 內的命令傳送給 Server ，它便會依照順序依次執行與記錄結果，最終將事務的結果回傳給 Client 。</p><h3 id="Lua-Script"><a href="#Lua-Script" class="headerlink" title="Lua Script"></a>Lua Script</h3><p>2.6 時 Redis 引入了 Lua 執行環境，也就是 2.6 版本之後就內建一個 Lua 的 Interpreter ，而 <a href="https://www.lua.org/" target="_blank" rel="noopener">Lua</a> 是一個極輕量的語言，它的目標是成為最容易嵌入其它語言的程式語言。</p><p>Redis 對於 Lua 的環境做了許多修改，以避免產生漏洞遭利用，此外也提供由 Lua 呼叫 Redis 命令的函式等。並且為了支援持久化功能， Redis 限制了 Lua 函式必須符合三點：</p><ol><li>沒有副作用</li><li>沒有有害的隨機性（比如隨機寫一個鍵值對）</li><li>同樣的輸入必得出同樣的結果</li></ol><p>Redis 保證了 Lua 的原子性，也就是當執行 Lua Script 時不會在中間執行其它 Lua Script 或 Redis Command 。</p><p>換句話說 Lua Script 本身就是一種 Transaction ，而且還比原本 <code>MULTI</code> / <code>EXEC</code> 更快更簡單。官方雖然短時間內不會移除舊版本的事務機制，但假使未來的使用者都傾向使用 Lua Script 來處理的話，最終可能會把舊有機制給移除。</p><p>我自己感覺 Lua Script 提供更多功能與靈活性，若沒特殊原因應該也會選擇 Lua ，但這邊不會再詳細介紹 Lua ，可能未來會找時間寫相關的雜學。</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://redis.io/" target="_blank" rel="noopener" title="官方網站">Redis</a></li><li><a href="https://draveness.me/whys-the-design-redis-single-thread" target="_blank" rel="noopener" title="面向信仰编程">为什么 Redis 选择单线程模型 · Why’s THE Design?</a></li><li><a href="http://redisbook.com/index.html" target="_blank" rel="noopener">Redis 设计与实现</a></li><li><a href="https://www.jianshu.com/p/xsMzfn" target="_blank" rel="noopener" title="简书">Redis阻塞操作实现原理</a></li><li><a href="http://redisdoc.com/index.html" target="_blank" rel="noopener">Redis 命令参考</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 程式 </category>
          
          <category> 資料庫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 淺入淺出 </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/10/29/hello-world/"/>
      <url>/2019/10/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Hello World</p><p>雖說原先累積了三頁左右的雜學，但因考量到幾年前的寫作方式與近乎照抄的內容，還是決定重來，果然大清除的時候對於不需要的東西要直接捨棄才好啊。</p><p>這次的 Blog 變動其實有想趁機改成用其它 Framework ，好比說 Hugo 、 Jekyll 這種，前者是 Go 語言寫的，優點是編譯速度非常快且我也比較熟悉；後者是 Ruby ，優點的話想不太到所以沒掙扎很久，雖然我有朋友大力推薦這門語言，但對它一直沒感覺。</p><p>但最終還是用 Hexo ，其一是想藉此學學放很久的前端技能，其二我真的蠻喜歡這個主題，想到換成別的又得重新找就覺得很累，以上。</p><h2 id="Hello-World-？"><a href="#Hello-World-？" class="headerlink" title="Hello World ？"></a>Hello World ？</h2><p>原本是想就這樣結束，但又覺得啥東西都沒有也怪怪的，所以來補充個學程式語言時最常見的例子『 Hello World 』吧。</p><p>這個範例知名到 <a href="https://wikipedia.org/wiki/Hello_World" target="_blank" rel="noopener">Wiki</a> 有專門的頁面，就連日本在 2019-09-20 都上映了<a href="https://hello-world-movie.com/index.html" target="_blank" rel="noopener">同名電影</a>。</p><p>依據 Wiki 中所述這是在 B 語言的文件《 A Tutorial Introduction to the Language B 》提到的 Hello World 例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">  extrn a,b,c;</span><br><span class="line">  putchar(a); putchar(b); putchar(c); putchar(&apos;!*n&apos;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">a &apos;hell&apos;;</span><br><span class="line">b &apos;o, w&apos;;</span><br><span class="line">c &apos;orld&apos;;</span><br></pre></td></tr></table></figure><p>這類例子的用意很單純，因為基本上是最簡單的程式，所以適合用來介紹語言特性，比如上面就能看到 B 語言的某些特性。<br>而這位作者後來與他人共同開發知名的 C 語言，教學中舉的例子也是 Hello World ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello, world\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有多少高手的第一個語言是 C 呢？絕對多到你數不清。</p><p>所以根據人的惰性與習慣，這些人後來在撰寫教學文件時，第一個例子想到 Hello World 就一點也不奇怪了。</p>]]></content>
      
      
      <categories>
          
          <category> 雜七雜八 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
