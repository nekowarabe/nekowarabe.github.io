<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Meet the PHP</title>
      <link href="/2020/02/16/meet-the-php/"/>
      <url>/2020/02/16/meet-the-php/</url>
      
        <content type="html"><![CDATA[<p>多年前曾因無奈使用 PHP ，這眾所皆知的「世界上最好的程式語言」寫了些東西。那時的衝擊害我後來對它只敢遠觀而不敢褻玩。</p><p>直到約一個月前應徵上了 Java 開發程式員，托福開始學習 PHP 。</p><p>對，你沒看錯，不要懷疑<br>Java 開發者用 PHP 開發有什麼問題嗎？有的話請找我公司洽談。</p><p>大概是因為第一個學的語言是被 Oracle 辣手摧殘的 Java，所以一直以來都不是很喜歡動態語言。型態不知道、屬性函式有沒有提供也不管這既是動態語言的強項，也是我最不喜歡的地方。</p><p>假使單人開發時使用動態語言我還可以理解，畢竟真的爽，想怎麼寫就怎麼寫。</p><p>明明都知道這個函式就只會丟字串，幹嘛還要每次都寫型態，反正是我自己呼叫、串接，輸入值會有哪些屬性、行為早就知道了，還要再補上轉型態啦、提示啦真的很麻煩耶。</p><p>只不過多人開發我覺得會是地獄，自由不棒嘛？當然棒，但自由也會帶來困惑，所以公司用動態語言寫真的讓我很痛苦。</p><p>……但是老實說我開始懷疑痛苦的原因該不會只是用了 PHP 吧？</p><h2 id="觀念破壞"><a href="#觀念破壞" class="headerlink" title="觀念破壞"></a>觀念破壞</h2><p>PHP 是第一個讓我有觀念被人當面撕碎，加水攪拌再潑我一臉的語言。</p><p>我認為 PHP 只適合兩種人：</p><ol><li>從來沒學過程式語言者</li><li>想學習新思維者</li></ol><p>再提一次因為我是 Java 出身，所以這些感覺可能只有我有。你沒有的話只代表我們的 Context 不同。（但歡迎分享其它看法）</p><h3 id="意思不同的符號"><a href="#意思不同的符號" class="headerlink" title="意思不同的符號"></a>意思不同的符號</h3><p>PHP 有些運算子的行為與我們想像的不同，直到現在我都不習慣它的字串相加。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python 的情況</span></span><br><span class="line">str = <span class="string">"Hello"</span> + <span class="string">" World"</span></span><br></pre></td></tr></table></figure><p>而 PHP 這麼與眾不同的語言，使用的是 <code>.</code> ：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PHP 的情況</span></span><br><span class="line">$str = <span class="string">"Hello"</span> . <span class="string">" World"</span>;</span><br></pre></td></tr></table></figure><p>我記憶中的 <code>.</code> 是呼叫函式或屬性的，現在真的很難轉過來。</p><p>最靠北的是在專案內那些不加空白的寫法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$url = $some_url.<span class="string">'?xxx_id='</span>.<span class="keyword">$this</span>-&gt;xxx_id;</span><br><span class="line">$buffer = $params_array[<span class="string">'no'</span>].$params_array[<span class="string">'amount'</span>].<span class="keyword">$this</span>-&gt;setting[<span class="string">'key'</span>].<span class="keyword">$this</span>-&gt;setting[<span class="string">'some_id'</span>];</span><br><span class="line">$postData[<span class="string">'Sign'</span>] = md5($postData[<span class="string">'Amount'</span>].<span class="string">'|'</span>.$postData[<span class="string">'MerId'</span>].<span class="string">'|'</span>.$postData[<span class="string">'MerOrderNo'</span>].<span class="string">'|'</span>.$postData[<span class="string">'MerOrderTime'</span>].<span class="string">'|'</span>.<span class="keyword">$this</span>-&gt;setting[<span class="string">'api_key'</span>]);</span><br></pre></td></tr></table></figure><p>厲害了我的點。</p><h3 id="變數"><a href="#變數" class="headerlink" title="變數"></a>變數</h3><p>動態語言變數沒有型態限制，你想賦予它什麼就是什麼。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python 的情況</span></span><br><span class="line">num = <span class="number">1</span></span><br><span class="line">num = <span class="string">"進化成字串"</span></span><br></pre></td></tr></table></figure><p>但是 PHP 多了一個規定，所有的變數皆以 <code>$</code> 開頭：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PHP 的情況</span></span><br><span class="line">$num = <span class="number">123</span>;</span><br><span class="line">$num = <span class="string">"就是愛錢啦"</span>;</span><br></pre></td></tr></table></figure><p>也許是因為以往都不會看到那麼多金錢符號，我現在看到 <code>$</code> 都很煩躁。</p><p>它有專門的稱呼叫 Variable variables （可變的變數），什麼意思呢？直接看個例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$a = <span class="string">"hello"</span>;</span><br><span class="line">$$a = <span class="string">"world"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"$a $&#123;$a&#125;"</span>;  <span class="comment">// 輸出： hello world</span></span><br><span class="line"><span class="keyword">echo</span> $hello;      <span class="comment">// 輸出： world</span></span><br></pre></td></tr></table></figure><p>你可能會心想：『這他媽三小？』</p><p>我來解釋一下演變過程：</p><ol><li>$a 取出指向的值 “hello”</li><li>$ + “hello” 轉變為 $hello</li><li>$hello 指向值 “world”</li></ol><p><img src="/images/black_question.jpg" alt="黑人問號"></p><p>「這到底他媽的是三小！？」</p><p>是個類似於 Pointer ，但又比它莫名其妙的鬼東西<br>我懷疑可能是太容易激起同事的殺人慾望，目前還沒在專案中看人用過。</p><p>但你知道的，有這種功能存在就一定有使用它的人。</p><h3 id="不是-Array-的-Array"><a href="#不是-Array-的-Array" class="headerlink" title="不是 Array 的 Array"></a>不是 Array 的 Array</h3><p>之前接觸過的語言 Array 都是連續記憶體空間，也就是那種可以隨機存取的資料結構。</p><p>但是唯我獨尊的 PHP 之 Array 本質是一個 <strong>Sorted Hash Table</strong> （可排序雜湊表），俗稱的 Map 或 Dictionary 結構。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看起來很正常</span></span><br><span class="line">$arr = <span class="keyword">array</span>(<span class="string">"A"</span>, <span class="number">100</span>, <span class="number">3.14159</span>);</span><br><span class="line">$arr[<span class="number">0</span>]; <span class="comment">// A</span></span><br><span class="line">$arr[<span class="number">1</span>]; <span class="comment">// 100</span></span><br><span class="line">$arr[<span class="number">2</span>]; <span class="comment">// 3.14159</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但實際上等同於</span></span><br><span class="line">$arr = [</span><br><span class="line">    <span class="number">0</span> =&gt; <span class="string">"A"</span>,</span><br><span class="line">    <span class="number">1</span> =&gt; <span class="number">100</span>,</span><br><span class="line">    <span class="number">2</span> =&gt; <span class="number">3.14159</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">$arr = <span class="keyword">array</span>(<span class="number">0</span> =&gt; <span class="string">"A"</span>, <span class="number">1</span> =&gt; <span class="number">100</span>, <span class="number">2</span> =&gt; <span class="number">3.14159</span>);</span><br></pre></td></tr></table></figure><p>PHP 中 Array 就是一切是神是萬物所歸。</p><p>要傳一堆變數？用 Array<br>回傳多個值？用 Array<br>臨時想弄個結構？用 Array  </p><p>PHP 你不用考慮到情景使用不同的結構，因為你他媽就只有 Array 可以用，而且它還提供了詭異的語法糖：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$arr = [<span class="string">'a'</span> =&gt; <span class="string">"Apple"</span>, <span class="string">'b'</span> =&gt; <span class="string">"Banana"</span>];</span><br><span class="line"></span><br><span class="line">$arr[] = <span class="string">"Cat"</span>;  <span class="comment">// [0 =&gt; "Cat", 'a' =&gt; "Apple", 'b' =&gt; "Banana"]</span></span><br><span class="line">$arr[<span class="number">0</span>];         <span class="comment">// Cat</span></span><br><span class="line"></span><br><span class="line">$arr[<span class="number">4</span>] = <span class="string">"Four"</span>; <span class="comment">// [0 =&gt; "Cat", 4 =&gt; "Four", 'a' =&gt; "Apple", 'b' =&gt; "Banana"]</span></span><br><span class="line">$arr[] = <span class="string">"Five"</span>;  <span class="comment">// [0 =&gt; "Cat", 4 =&gt; "Four", 5 =&gt; "Five", 'a' =&gt; "Apple", 'b' =&gt; "Banana"]</span></span><br><span class="line">$arr[<span class="number">5</span>];          <span class="comment">// Five</span></span><br></pre></td></tr></table></figure><p>太棒了，我還以為 <code>$array[] = XXX</code> 是重新指派 Array 呢，都內建一大堆函式了多個 <code>array_append</code> 之類的東西很難膩？</p><h3 id="特殊變數或常數"><a href="#特殊變數或常數" class="headerlink" title="特殊變數或常數"></a>特殊變數或常數</h3><p>PHP 是以 Web 為目的的語言，它充斥著滿滿的特殊變數在其中。</p><table><thead><tr><th align="center">Name</th><th align="center">Desc</th></tr></thead><tbody><tr><td align="center">$GLOBAL</td><td align="center">程式定義的所有全域變數陣列</td></tr><tr><td align="center">$_ENV</td><td align="center">執行環境相關陣列</td></tr><tr><td align="center">$_GET</td><td align="center">使用 HTTP Get 時傳遞的參數</td></tr><tr><td align="center">$_POST</td><td align="center">使用 HTTP Post 時傳遞的參數</td></tr><tr><td align="center">$_REQUEST</td><td align="center">存放與 Request 相關的資料</td></tr></tbody></table><p>除此之外還有常數，早期只能透過 <code>define(Name, Value, CaseSenstive?)</code> 這個內建函式定義，直到 5.3 之後才可以使用 const 關鍵字。</p><blockquote><p>但我看到大多數還是使用 define ，不太清楚原因</p></blockquote><p>因為這些特殊變數、魔術常數等都屬於全域，在全域的環境中做任何事都得先想想以免出錯找不到原因。</p><h3 id="需要修改-php-ini-來開啟函式庫"><a href="#需要修改-php-ini-來開啟函式庫" class="headerlink" title="需要修改 php.ini 來開啟函式庫"></a>需要修改 php.ini 來開啟函式庫</h3><p>這個我不確定有沒有其它解決方法。</p><p>專案有個串接的三方 API 是使用 SOAP 協議，而在 PHP 可以用 SoapClient 這個類別。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$client = <span class="keyword">new</span> SoapClient(<span class="string">"...?wsdl"</span>);</span><br><span class="line"></span><br><span class="line">$params = <span class="keyword">array</span>(...);</span><br><span class="line">$res = $client-&gt;__soapCall(<span class="string">'METHOD'</span>, $params);</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>但開始測試時出現了錯誤，表示找不到 SoapClient Class 。</p><p>拜請了 Google 大神後發現得修改 php.ini 來啟用，我他媽第一次看到使用官方函式庫是透過更改語言設定才能用，摩達佛咖。</p><h3 id="多到不可思議的關鍵字"><a href="#多到不可思議的關鍵字" class="headerlink" title="多到不可思議的關鍵字"></a>多到不可思議的關鍵字</h3><p>各種各樣的關鍵字出現在 PHP 中，不斷讓我感到困惑。</p><p>好比說 include 與 require 這兩個他媽的幾乎一樣的關鍵字，差別在於 include 即使檔案不存在也不會報錯，所以大家都推薦使用 require ，我說那個 include 的存在價值呢？</p><p>還有特殊的實體關鍵字，比如可以透過：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不論如何都會實例化當前這個類別</span></span><br><span class="line">$real_me = <span class="keyword">new</span> <span class="keyword">self</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 會實例化執行期的類別，好比說 Son 繼承後執行此段會實例化 Son</span></span><br><span class="line">$runtime_me = <span class="keyword">new</span> <span class="keyword">static</span>();</span><br></pre></td></tr></table></figure><p>還有為了提供不寫花括號而增加的 end 系列：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原本的寫法</span></span><br><span class="line"><span class="keyword">if</span> ($x == <span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"X is true"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">", real true"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"X is not true"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">", real false"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改用冒號與 end 結尾</span></span><br><span class="line"><span class="keyword">if</span> ($x == <span class="keyword">true</span>):</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"X is true"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">", real true"</span>;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"X is not true"</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">", real false"</span>;</span><br><span class="line"><span class="keyword">endif</span>;</span><br></pre></td></tr></table></figure><p>選擇超多的，棒！</p><h3 id="官方無規範"><a href="#官方無規範" class="headerlink" title="官方無規範"></a>官方無規範</h3><p>官方的函式庫理應照著一套準則，這樣開發者使用時比較不會有困惑感，但是：</p><ul><li>strptime ： C 語言函式</li><li>nl2br ：縮寫</li><li>htmlspecialchars ：全寫</li><li>json_encode ：底線區隔</li></ul><p>最可悲的是這不是偶然，據說是因為作者以函式的名字為函式的 Hash 值，因此 PHP 中的函式都盡可能的長短皆有、均勻分布。</p><p>PHP 內建的函式多的誇張，所以 PHP 開發者最常做的事情就是去查看官方手冊。</p><p>聽起來雖然很正常，但因為所有類型的函式皆放在一塊（ Global ），所以你根本不知道字串操作、加密解密都提供了甚麼函式給你，還曾發生過版更替時將舊有的函式給移除的情況，手中沒個 PHP 手冊寫起程式抖得跟什麼一樣。</p><p>變數雖然大小寫敏感，但是函式與類別都不敏感，到底幹嘛這樣設計，能像下面那樣寫是很 Coooooooool 是嗎？</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ctrl = <span class="keyword">new</span> SUPeRCOntroLLEr();</span><br><span class="line">$res = $ctrl-&gt;HANdle($input);</span><br><span class="line"></span><br><span class="line">$body = $res-&gt;GeTBoDy();</span><br></pre></td></tr></table></figure><p>就連型態都有好幾種寫法，以下都是一樣的：</p><ul><li>int/integer</li><li>bool/boolean</li><li>float/double/real</li></ul><p><a href="https://www.php.net/manual/en/function.is-real.php" target="_blank" rel="noopener">real</a> 是三小……</p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>經過這段時間其實我多少也了解了公司要使用 PHP 的原因，它確實具備某些特性與公司需求吻合。</p><p>但我依然得老實說這個語言完全給我走一步算一步的感覺，東抄西抄全都混在一起做撒尿牛丸，原本覺得因為各種歷史包袱不方便改，但版本迭代更新卻直接移除舊有的內建函式。</p><p>所以看來也不是沒辦法改嘛！</p><p>拜託把語法整合一下，函式命名邏輯統一點不要製造一堆驚喜真的很難嗎？</p><p>也許 PHPer 就是愛上這種充滿驚喜的感覺，有了驚喜就多了笑容：</p><p><img src="before_after.jpg" alt="前後比對照"></p><p>我想，還是只能說：「啊， PHP 真的是世界上最好的語言了。」</p><h2 id="推薦閱讀"><a href="#推薦閱讀" class="headerlink" title="推薦閱讀"></a>推薦閱讀</h2><p><a href="https://www.zhihu.com/question/26498147" target="_blank" rel="noopener">「PHP 是最好的语言」这个梗是怎么来的？</a></p>]]></content>
      
      
      <categories>
          
          <category> 程式 </category>
          
          <category> 雜七雜八 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>淺入淺出 Float</title>
      <link href="/2020/01/15/float-intro/"/>
      <url>/2020/01/15/float-intro/</url>
      
        <content type="html"><![CDATA[<p>Float 俗稱浮點數，它相當於我們上課時學到的小數。</p><p>雖然在程式設計中是相當重要的概念，但很少有人會花心思去搞懂它，大多書籍也不會詳細解說 Float 的原理或儲存方式，更不用說為什麼浮點數計算時會出問題了。</p><h2 id="IEEE754"><a href="#IEEE754" class="headerlink" title="IEEE754"></a>IEEE754</h2><p>先介紹目前業界中最通用的標準，由 <em>William Morton Kahan</em> 的研究而制定，他也因此被稱為「浮點數之父」。</p><p>這個規範定義了四種 Float 的表示方式：</p><ol><li>單精度（ 32 bit ）</li><li>雙精度（ 64 bit ）</li><li>延伸單精度（ 43 bit 以上）</li><li>延伸雙精度（ 79 bit 以上，通常用 80 bit 實作）</li></ol><blockquote><p>IEEE 754 只有對單精度強制要求提供，其餘三種可選。不過目前大多數語言都有提供雙精度</p></blockquote><h2 id="儲存概念"><a href="#儲存概念" class="headerlink" title="儲存概念"></a>儲存概念</h2><p>在計算機的世界中萬物皆 bit ，無論整數或浮點數皆是如此。</p><p>只不過整數間無法切割， 1 ～ 10 只會有 10 個數字；小數間可以無限切割， 0 ～ 1 就擁有無限個小數，畢竟小數點後可以無限增加數字，卻對數值不會有太大的影響。</p><p>所以整數即使只單純用 bit 儲存也沒關係，例如 8 bit 可以表現出 2<sup>8</sup> 種狀態，用在整數上可以表示 0 ～ 255 ；用在小數上則連 0 ～ 1 都表現不完，所以 Float 的儲存方式註定要與 Int 不同。</p><p>如果以單精度來看 32 bit 可以表現出約 40 億種狀態，但如前面所說的這連 0 ～ 1 之間都不夠用，必須使用特殊的格式才行，再加上考慮到極大值與極小值中間往往會塞很多無意義的 0 ，它們基本上只是浪費記憶體空間，所以使用了 Scientific notation （科學記號）的概念來保存。</p><blockquote><p>科學記號是一種簡略地表示值的方法，好比說 1,234,500,000,000 -&gt; 1.2345 * 10<sup>12</sup> 或是 0.00000054321 -&gt; 5.4321 * 10<sup>-7</sup></p></blockquote><p>數值越大或越小時科學記號就越能發揮用途（節省無意義的 0 ），計算機科學中常常以 E 或 Exp （ Exponential ）來表示指數，也就是 10<sup>E</sup> ：</p><ul><li>1.2345E12</li><li>5.4321E-7</li></ul><p>在基於科學記號的概念， Float 儲存時的可以分為三個部分： <code>Sign</code> 、 <code>Exponent</code> 、 <code>Fraction</code> 。</p><h3 id="Sign"><a href="#Sign" class="headerlink" title="Sign"></a>Sign</h3><p>用來表示 Float 是為正或負，因為只有兩種狀態（ + / - ）所以不論哪個精度都只需要 1 bit 表示。</p><h3 id="Exponent"><a href="#Exponent" class="headerlink" title="Exponent"></a>Exponent</h3><p>指數的數值，此處的基數不再是 10 而是 2 ，這與 Float 的計算方式有關。</p><p>要注意它儲存的不是實際的值而是偏移後的值， Exponent 處理時會加減一個 Bias （偏移值）， Bias 的算法為 2<sup>n-1</sup> - 1 （ n 為 Exponet 的位元大小），以單精度為例的話就是 2<sup>8-1</sup> - 1 = 127 ，這麼做的原因可能是為了比較大小（排序）時的方便，因為可以直接看 bit 決定誰大。</p><blockquote><p>存有號數 0b11111101 （ -3 ） 與 0b00000011 （ 3 ） 在比較時還需考慮正負數，而無號數 0b01111100 （ 124 ）與 0b10000010 （ 130 ）直接從高位的 bit 比就知道誰更大</p></blockquote><h3 id="Fraction"><a href="#Fraction" class="headerlink" title="Fraction"></a>Fraction</h3><p>也稱為有效數，這裡是實際上數值的部分，換句話說浮點數的實際精度就是受此影響。</p><h2 id="實際儲存"><a href="#實際儲存" class="headerlink" title="實際儲存"></a>實際儲存</h2><p>Float 在儲存時一樣先經過二位元處理再儲存，以 6.375 來當例子，整數部分可以拆解為 (1 * 2<sup>2</sup>) + (1 * 2<sup>1</sup>) + (0 * 2<sup>0</sup>) ；分數部分可以拆解為 (0 * 2<sup>-1</sup>) + (1 * 2<sup>-2</sup>) + (1 * 2<sup>-3</sup>) ：</p><p><img src="float-to-binary.jpg" alt="位元轉換圖"></p><p>假設正負次方之間透過 <code>.</code> 來做隔離，那麼我們可以得到 6.375 的二位元 0b110.011 ，接著為了儲存到 Fraction 會將其轉換為科學記號形式：</p><p><img src="binary-to-fraction.jpg" alt="轉換為科學記號"></p><p>這邊利用了科學記號的概念，將 Float 給統一規格化，只不過原本是用於十進制上，所以轉化為科學記號後整數部分不會大於 10 ，但 bit 是逢二進位所以變為整數部分不會大於 2 ，這也是 Exponent 的基數為 2 的原因。</p><p>加上二位元的世界裡全部 bit 都為 0 的數就只有 0 ，其它數絕對會在裡面出現一次 1 ：</p><ul><li>0 -&gt; 0b00000000</li><li>1 -&gt; 0b00000001</li><li>7 -&gt; 0b00000111</li><li>128 -&gt; 0b10000000</li><li>⋯⋯</li></ul><p>因此非 0 的數必定可以轉換為 <code>0b1.xxx⋯⋯</code> 的形式，這樣儲存的時候還可以省略 <code>1.</code> （畢竟所有數都有）來多紀錄 1 bit 。</p><p>最終取得了 Exponent 與 Fraction 的值：</p><ul><li>Exponent = 2 + 127 = 129 （ 0b10000001 ）</li><li>Fraction = 0b10011</li></ul><p>用單精度的 Float 二位元表示：</p><table><thead><tr><th align="center">Sign</th><th align="center">Exponent</th><th align="center">Fraction</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">10000001</td><td align="center">10011000000000000000000</td></tr></tbody></table><h2 id="特殊規格"><a href="#特殊規格" class="headerlink" title="特殊規格"></a>特殊規格</h2><p>IEEE 754 也考量到許多特殊狀況，其一是展示的格式；其二是特殊值，可以參考下表：</p><table><thead><tr><th align="center">Exponent</th><th align="center">Fraction</th><th align="center">Mean</th></tr></thead><tbody><tr><td align="center">全 0</td><td align="center">全 0</td><td align="center">Zero</td></tr><tr><td align="center">非全 0</td><td align="center">不限</td><td align="center">Normalized</td></tr><tr><td align="center">全 0</td><td align="center">非全 0</td><td align="center">Denormalized</td></tr><tr><td align="center">全 1</td><td align="center">全 0</td><td align="center">Infinaty</td></tr><tr><td align="center">全 1</td><td align="center">非全 0</td><td align="center">Not a Number</td></tr></tbody></table><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>Float 實際上擁有 Normalized （正規格式）與 Denormalized （非正規格式）兩種形式，<a href="#實際儲存">前面</a>介紹的是 Normalized 。</p><p>之所有會有 Denormalized 的主要原因在於正數最小值被當初 Fraction 偷了 1 bit 影響到，如果只有 Normalized 的話單精度最小值應該是：</p><table><thead><tr><th align="center">Sign</th><th align="center">Exponent</th><th align="center">Fraction</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">00000000</td><td align="center">00000000000000000000001</td></tr></tbody></table><p>Exponent 的部分是 2<sup>0-127</sup> 約為 5.8E-39 ，而 Fraction 前方必須加 <code>1.</code> 所以是 2<sup>0</sup> + 2<sup>-23</sup> 約為 1 ，最小值算出來是 <strong>5.8E-39</strong> ，很明顯的那個 <code>1.</code> 影響了整個結果，它導致後面的 2<sup>-23</sup> 有跟沒有一樣，完全浪費掉 23 bit 。</p><p>基於此情況， IEEE 754 規定當 Exponent 為 0 但 Fraction 不為 0 時啟用 Denormalized 格式，這種格式下 Fraction 前方不用再加 <code>1.</code> 而 Exponent 則強制為 1 - Bias ，所以可以得到最小值為 2<sup>-23</sup> * 2<sup>-126</sup> 約為 <strong>1.4E-45</strong> 。</p><blockquote><p>Exponent 強制為 1 - Bias 的原因是為了與無 Denormalized 狀況下的最小值連接，理論上純 Normalized 最小值是 (2<sup>0</sup> + 2<sup>-23</sup>) * 2<sup>-127</sup> ，而 Denormalized 的最大值是 2<sup>-1</sup> * 2<sup>-126</sup> ， 2<sup>-23</sup> 影響太小可以無視，所以這兩者值近乎一樣</p></blockquote><p>不過因為多了 Denormalized 所以目前 Normalized 最小值是 Exponent 為 1 但 Fraction 為 0 ，也就是 2<sup>0</sup> * 2<sup>1-127</sup> 約 <strong>1.17E-38</strong> 。</p><h3 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h3><p>特殊值實際上就是 <code>Zero</code> 、 <code>Inf</code> 、 <code>NaN</code> 三者，而雖然那個表格中少了 Sign 這個符號位，但它是有作用的。</p><p>因此 Float 有了很詭異的 <a href="https://zh.wikipedia.org/wiki/-0" target="_blank" rel="noopener">-0</a> 值，在理論上它應該與 0 相等，而無窮數的部分比較正常，分為 +Inf 與 -Inf ，不會有語意上的問題。</p><p>NaN （非數值）這個概念最早就是來自於 IEEE 754 規範，通常指的是無法被表示的數字，好比說：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b <span class="keyword">float32</span></span><br><span class="line"></span><br><span class="line">fmt.Println(a / b)  <span class="comment">// 除以零， NaN</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">float64</span> = <span class="number">-1.0</span></span><br><span class="line"></span><br><span class="line">fmt.Println(math.Sqrt(c))  <span class="comment">// 負數開平方根， NaN</span></span><br></pre></td></tr></table></figure><p>NaN 因其名 Not a Number 並不是一個固定的數值，換句話說它與誰做比較都不相等，即使是跟自己：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b <span class="keyword">float32</span></span><br><span class="line"><span class="keyword">var</span> NaN <span class="keyword">float32</span> = a / b</span><br><span class="line"></span><br><span class="line">fmt.Println(NaN == NaN)  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>NaN 應被視為運作失敗的結果而不能跟任何數值做比對，通常來說程式語言都會提供相應的函式以供辨識。</p><h2 id="浮點數的精度失真"><a href="#浮點數的精度失真" class="headerlink" title="浮點數的精度失真"></a>浮點數的精度失真</h2><p>浮點數透過 2 的負次方來組成，但是你會發現連最簡單的 0.1 都不可能組合成功：</p><p><img src="float-precision.jpg" alt="永遠達不到的 0.1"></p><p>不管如何擴充永遠也加不到剛好 0.1 ，而 Float 的位元數量有限不可能無窮的保存下去，最終就會出現精度遺失的狀況，下面是單精度的 0.1 二位元：</p><table><thead><tr><th align="center">Sign</th><th align="center">Exponent</th><th align="center">Fraction</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">01111011</td><td align="center">10011001100110011001101</td></tr></tbody></table><p>依照前面介紹過的 Normalized 來轉換會得到 Exponent = 2<sup>123-127</sup> ； Fraction = 1.6000000238 ，兩者相乘 1.6000000238 * 2<sup>-4</sup> = <strong>0.1000000015</strong> ，即使切換成雙精度也不會改變結果，這也可以說是十進位與二進位的分數轉換天生就有問題。</p><h3 id="精度位數"><a href="#精度位數" class="headerlink" title="精度位數"></a>精度位數</h3><p>浮點數在某個範圍是精確的，但超過之後的結果就無法保證，其原因當然在 Fraction 身上。</p><p>拿單精度來說， 23 個 bit 可以表示出 8,388,608 種狀態，雖然 Float 的機制多偷 1 bit 也許該算作 24 bit ，但實際上那個 bit 等於被強制固定住，並沒有實質意義在。</p><p>總之，狀態表達雖然高達 7 位數字，但實際上能準確表達的範圍只有 6 位。這是因為在 8,388,608 之後的狀態就無法表示（好比說 9,000,000 ），所以單精度雖然某些 7 位數也可以準確表達，但因為不是每個 7 位數都可以，正常還是會說單精度的有效位數為 6 位。</p><p>有人可能無法理解為什麼 Fraction 狀態數量會與 Float 的有效位數有關，因為不是還有 Exponent 在嗎？</p><p>Exponent 只能 “ 移動 “ Fraction 的位置而已，狀態數量是固定的，好比說 2 bit 可以表現 4 種狀態，往前移動之後還是只有 4 種：</p><p><img src="exp-move-bits.jpg" alt="不論往前或往後狀態數都不變"></p><p>很明顯的移動後增加或減少的 bit （概念上的）不會影響到 Fraction 所能表示的狀態，這就是為何 Exponent 影響不到精度的原因。</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://zh.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener">IEEE 754 Wiki</a><br><a href="https://www.cnblogs.com/HDK2016/p/10506083.html" target="_blank" rel="noopener">【算法】解析IEEE 754 標準</a><br><a href="https://github.com/camsong/blog/issues/9" target="_blank" rel="noopener">JavaScript 浮点数陷阱及解法</a></p>]]></content>
      
      
      <categories>
          
          <category> 程式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 淺入淺出 </tag>
            
            <tag> float </tag>
            
            <tag> 浮點數 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>淺入淺出 JWT</title>
      <link href="/2020/01/01/jwt-intro/"/>
      <url>/2020/01/01/jwt-intro/</url>
      
        <content type="html"><![CDATA[<p>JWT （ JSON Web Token ）正如其名是一種將 JSON 作為 Token 來使用的構想，傳統的 Token 單純只為了身份驗證，但 JWT 因為是 JSON 而可以攜帶額外資訊在身上，所以適合用於分散式的系統。</p><h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>Token 中文意思是象徵、標示（中國稱令牌），是種身份驗證的機制。</p><p>大部分的系統在做與個人隱私有關的操作時往往因安全考量，要求提供帳號與密碼<br>但如果系統<strong>每次</strong>都要求使用者提供帳號與密碼的話，容易讓使用者感到麻煩。</p><p>而 Token 類似臨時的身份證，需由官方（ Server ）發給會員（ Client ）<br>當你出示 Token 給官方時就不必在提供帳號密碼等資料，因為證書提供了保證。</p><blockquote><p>Token 依據規範通常是放在 HTTP 請求的 Authorization Header ，還會加上 Bearer 前綴，比如 <code>Authorization: Bearer &lt;YOUR_TOKEN&gt;</code></p></blockquote><h2 id="JWT-不是-JWT"><a href="#JWT-不是-JWT" class="headerlink" title="JWT 不是 JWT"></a>JWT 不是 JWT</h2><p>多數人所熟知的 JWT 大多長得像：</p><p><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiTmVrbyIsImFnZSI6NjZ9.rRtZGDRTwa5jexCmki-lojh4m8plXNQnZPxI8vKh4g0</code></p><p>但實際上這是被稱為 JWS （ JSON Web Signature ）的格式。</p><p>關於 JSON 充當 Token 的規範其實共有五份：</p><ul><li><a href="https://tools.ietf.org/html/rfc7518" target="_blank" rel="noopener">JSON Web Algorithms</a></li><li><a href="https://tools.ietf.org/html/rfc7517" target="_blank" rel="noopener">JSON Web Key</a></li><li><a href="https://tools.ietf.org/html/rfc7519" target="_blank" rel="noopener">JSON Web Token</a></li><li><a href="https://tools.ietf.org/html/rfc7515" target="_blank" rel="noopener">JSON Web Signature</a></li><li><a href="https://tools.ietf.org/html/rfc7516" target="_blank" rel="noopener">JSON Web Encryption</a></li></ul><p>皆是由 IETF 的 <a href="https://datatracker.ietf.org/wg/jose/charter/" target="_blank" rel="noopener">JOSE</a> （ Javascript Object Signing and Encryption ）所制訂的 RFC 標準。</p><p>由於大多數人使用的只是 JWS 格式，而且比起 JWS 來說 JWT 更明顯地表示出是以 <strong>JSON</strong> 來當 <strong>Token</strong> 使用，再加上為了避免額外資訊帶來的困擾，介紹時通常就會省略其它不常使用的規範，久而久之對於 JWT 的印象就固定下來。</p><p>雖然沒想平反這種錯誤印象，但還是會稍微地介紹每種規格。</p><h3 id="JWA"><a href="#JWA" class="headerlink" title="JWA"></a>JWA</h3><p>JWA 定義了 JOSE 中 JWS 、 JWE 與 JWK 相關的加密演算法。</p><p>JWA 規定了幾種演算法是必須提供實作，也要求它們的代稱必須一致，而 JWS 與 JWE 之間的規範不同，以下為 JWS 演算法規範：</p><table><thead><tr><th align="center">代稱（名稱）</th><th align="center">演算法</th><th align="center">是否提供</th></tr></thead><tbody><tr><td align="center">HS256</td><td align="center">HMAC - SHA-256</td><td align="center">必須</td></tr><tr><td align="center">HS384</td><td align="center">HMAC - SHA-384</td><td align="center">可選</td></tr><tr><td align="center">HS512</td><td align="center">HMAC - SHA-512</td><td align="center">可選</td></tr><tr><td align="center">RS256</td><td align="center">RSASSA-PKCS1-v1_5 - SHA-256</td><td align="center">建議</td></tr><tr><td align="center">RS384</td><td align="center">RSASSA-PKCS1-v1_5 - SHA-384</td><td align="center">可選</td></tr><tr><td align="center">RS512</td><td align="center">RSASSA-PKCS1-v1_5 - SHA-512</td><td align="center">可選</td></tr><tr><td align="center">ES256</td><td align="center">ECDSA - P-256 ＆ SHA-256</td><td align="center">強烈建議</td></tr><tr><td align="center">ES384</td><td align="center">ECDSA - P-384 ＆ SHA-384</td><td align="center">可選</td></tr><tr><td align="center">ES512</td><td align="center">ECDSA - P-521 ＆ SHA-512</td><td align="center">可選</td></tr><tr><td align="center">PS256</td><td align="center">RSASSA-PSS - SHA-256 &amp; MGF1 - SHA-256</td><td align="center">可選</td></tr><tr><td align="center">PS384</td><td align="center">RSASSA-PSS - SHA-384 &amp; MGF1 - SHA-384</td><td align="center">可選</td></tr><tr><td align="center">PS512</td><td align="center">RSASSA-PSS - SHA-512 &amp; MGF1 - SHA-512</td><td align="center">可選</td></tr><tr><td align="center">none</td><td align="center">無</td><td align="center">可選</td></tr></tbody></table><blockquote><p>none 演算法即<strong>不防偽</strong>，正常情況是不會使用的。官方建議如果函示庫有提供此實作，應給予一個是否開啟的選項讓使用者決定允不允許 none</p></blockquote><h3 id="JWK"><a href="#JWK" class="headerlink" title="JWK"></a>JWK</h3><p>JWK 定義了加密演算法中使用到的 Key 資料結構，視為一種 JSON 即可，例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"kty"</span> : <span class="string">"EC"</span>,</span><br><span class="line">    <span class="attr">"crv"</span> : <span class="string">"P-256"</span>,</span><br><span class="line">    <span class="attr">"x"</span> : <span class="string">"f83OJ3D2xF1Bg8vub9tLe1gHMzV76e8Tus9uPHvRVEU"</span>,</span><br><span class="line">    <span class="attr">"y"</span> : <span class="string">"x_FEzRu9m36HLN_tue659LNpXW6pCyStikYjKIWI5a0"</span>,</span><br><span class="line">    <span class="attr">"kid"</span> : <span class="string">"Public key used in JWS spec Appendix A.3 example"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這個 JWK 擁有橢圓曲線加密（ ECC ）類的參數 <code>crv</code> 、 <code>x</code> 、 <code>y</code> ，並有規定的 kty （ Key Type ）與 kid （ Key ID ）屬性。</p><h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><p>JWT 定義了幾種特別的屬性，主要是給 JWS （ Payload ）與 JWE （ Ciphertext ）的額外資訊使用，但都是可選屬性，不一定得使用在 JWS 或 JWE 中。</p><p>規範中將這些屬性稱為 Claims ，以下為官方要求：</p><table><thead><tr><th align="center">屬性名稱</th><th align="center">屬性型態</th><th align="center">意思</th></tr></thead><tbody><tr><td align="center">iss</td><td align="center">String</td><td align="center">Token 發行者</td></tr><tr><td align="center">sub</td><td align="center">String</td><td align="center">主題，屬性值應為唯一</td></tr><tr><td align="center">aud</td><td align="center">String / String Array</td><td align="center">Token 接收方，最少要包含發行者否則 Token 視為無效</td></tr><tr><td align="center">exp</td><td align="center">NumberDate</td><td align="center">過期時間，超過時 Token 應視為無效</td></tr><tr><td align="center">nbf</td><td align="center">NumberDate</td><td align="center">生效時間，未到時 Token 應視為無效</td></tr><tr><td align="center">iat</td><td align="center">NumberDate</td><td align="center">發行時間，此 Token 建立的時間</td></tr><tr><td align="center">jti</td><td align="center">String</td><td align="center">JWT ID ，如果有多個發行者應確保不會有 ID 衝突</td></tr></tbody></table><blockquote><p>形態的 String 須為大小寫敏感； NumberDate 是自 <code>1970-1-1T00:00:00Z UTC</code> 開始的秒數</p></blockquote><p>除了用於額外資訊的屬性， JWT 也定義了提供給 JWS 與 JWE 使用的 JOSE Header 共用屬性，總共兩個：</p><ul><li>typ</li><li>cty</li></ul><p>這兩個都是指 <a href="https://www.iana.org/assignments/media-types/media-types.xhtml" target="_blank" rel="noopener">Media Type</a> ，差別在於 typ 指的是 Token ； cty 指的是額外資訊，當然這兩個屬性也是可選，不過除非已經知道 Token 是 JWT ，否則應提供 typ 來標示此 Token 為 JWT 。</p><blockquote><p>官方建議屬性值應去掉 <code>application/</code> 的前綴，比如 <code>application/xml</code> 應直接寫 <code>xml</code> ，如果使用大小寫不敏感的做法，官方強烈建議 jwt 應全使用大寫的 JWT</p></blockquote><h3 id="JWS"><a href="#JWS" class="headerlink" title="JWS"></a>JWS</h3><p>JWS 定義了如何簽名 Token 以防止內容資料被竄改。</p><p>表示法有 Compact （精簡） 與 JSON 格式，前者是最常用的而後者幾乎沒人用過，以下是例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* Compact</span><br><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiTmVrbyIsImFnZSI6NjZ9.rRtZGDRTwa5jexCmki-lojh4m8plXNQnZPxI8vKh4g0</span><br><span class="line"></span><br><span class="line">* JSON</span><br><span class="line">&#123;&quot;payload&quot;:&quot;eyJuYW1lIjoiTmVrbyIsImFnZSI6NjZ9&quot;,&quot;signatures&quot;:[&#123;&quot;protected&quot;:&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9&quot;,&quot;header&quot;:&#123;&quot;kid&quot;:&quot;1asE21wFR4&quot;&#125;,&quot;signature&quot;:&quot;rRtZGDRTwa5jexCmki-lojh4m8plXNQnZPxI8vKh4g0&quot;&#125;]&#125;</span><br></pre></td></tr></table></figure><p>JSON 格式就只是 JSON 轉換為字串，不知道是因為太過智障還是難看，大多數的人都會使用 Compact 。</p><p>JWS 總共由三個部分組成（皆須透過 Base64URL 來編碼）：</p><ol><li>JOSE Header</li><li>Payload</li><li>Signature</li></ol><p>JOSE Header 的部分不只 JWT 定義的屬性還有 JWS 自定義的值，其中除了 alg 以外大多是可選的故不額外介紹，想知道還有哪些<a href="https://tools.ietf.org/html/rfc7515#section-4.1" target="_blank" rel="noopener">請點此</a>。</p><blockquote><p>alg 表示此 JWS 用來簽名的加密演算法，值應為 <a href="#JWA">JWA</a> 所定義的代稱</p></blockquote><p>最簡單的 Header 看起來應為：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"typ"</span> : <span class="string">"JWT"</span>,</span><br><span class="line">    <span class="attr">"alg"</span> : <span class="string">"HS256"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 Payload 就是一個使用者自訂的 JSON ，好比說：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"id"</span> : <span class="number">1010</span>,</span><br><span class="line">    <span class="attr">"name"</span> : <span class="string">"Neko"</span>,</span><br><span class="line">    <span class="attr">"age"</span> : <span class="number">66</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Signature 是將上述的兩個部分先透過 Base64URL 編碼，接著以 <code>.</code> 組成作為演算法輸入值來計算出來的，請參考下列虛擬碼：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">header = &#123;typ: &quot;JWT&quot;, alg: &quot;HS256&quot;&#125;</span><br><span class="line">payload = &#123;id: 1010, name: &quot;Neko&quot;, age: 66&#125;</span><br><span class="line"></span><br><span class="line">header = Base64URL(header)</span><br><span class="line">payload = Base64URL(payload)</span><br><span class="line"></span><br><span class="line">input = header + &quot;.&quot; + payload</span><br><span class="line">signature = Base64URL(HMAC256(input))</span><br></pre></td></tr></table></figure><p>取得完三個部分後，透過 <code>.</code> 連接起來就會得到 JWS Compact 的 Token ：</p><p><code>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpZCI6MTAxMCwibmFtZSI6Ik5la28iLCJhZ2UiOjY2fQ.B6VQtIs8BRUIxTZHmIcR3fQ3asJlgT7bt8AfxmbP650</code></p><h3 id="JWE"><a href="#JWE" class="headerlink" title="JWE"></a>JWE</h3><p>JWS 其實很明顯可以看出資訊是公開的，畢竟只有透過 Base64URL 編碼過，相當容易就可以透過解碼取得資料內容，對於真正需要隱藏的資料，應該使用 JWE 。</p><p>JWE 由五個部分組成，所以兩個的 Token 很明顯可以看出不同：</p><ol><li>JOSE Header</li><li>Encrypted Key</li><li>Initialzation Vector</li><li>Ciphertext</li><li>Authentication Tag</li></ol><p>其實很明顯可以看出有加密用的公鑰與初始向量等資訊在其中，我並沒有仔細看 JWE 的規範所以對他真的有興趣者請參考之前提供的規範網址或是到 <a href="https://blog.othree.net/log/2016/08/13/json-web-token/" target="_blank" rel="noopener">O3noBlog - JSON Web Token</a> 。</p><h2 id="適合的情況"><a href="#適合的情況" class="headerlink" title="適合的情況"></a>適合的情況</h2><p>JWT 能夠額外攜帶資訊這點使其適合用於分布式系統，除了可以省略部分資料同步的困擾外，也能某種程度上減少 I/O 操作。</p><p>如果以修改使用者資料來看，傳統的 Token 需要做 2 次資料庫 I/O ：</p><p><img src="update-use-token.jpg" alt="傳統 Token 更新"></p><p>但如果是 JWT 則只需要做 1 次資料庫 I/O ：</p><p><img src="update-use-jwt.jpg" alt="JWT 更新"></p><p>或是基於有額外資訊這點， JWT 也相當適合用於一次性認證，比方說帳號認證、忘記密碼等。</p><h2 id="問題與建議"><a href="#問題與建議" class="headerlink" title="問題與建議"></a>問題與建議</h2><p>不過也有些很明顯的缺點，好比說 JWT 是無法被註銷，當 Server 簽發出去就只能等到過期（ exp ），沒有方法可以藉由 Server 來註銷。</p><p>此外 JWS 的 Payload 相當於公開，所以也不該在裡面放較為隱私的資訊，再考慮到 URL 長度限制或 Cookie 大小（ 4K ）， JWT 也不應該太長。</p><p>綜上所述，在使用 JWT 機制時應確保：</p><ul><li>不放敏感資料</li><li>不放常變動的資料（否則得不斷生成新的 Token ）</li><li>設置 exp 且時間不得太長</li><li>設置 jti 或 exp 來改變生成的 JWT ，極端點可以每次都換密鑰</li><li>Server 應維護 Active Token 列表或是黑名單列表來控制 JWT</li></ul><h2 id="關於一些錯誤印象"><a href="#關於一些錯誤印象" class="headerlink" title="關於一些錯誤印象"></a>關於一些錯誤印象</h2><p>很多人都覺得 JWT 拯救了世界，其實沒有。</p><p>比如說有人覺得 JWT 可以防止 CSRF （ Cross Site Request Forgery ）攻擊，但 CSRF 運作是透過 JavaScript 來運作的（當然還有手賤亂點），是 Token 就沒辦法避免攻擊。</p><p>或有人覺得 JWT 更加安全，但這也沒有，畢竟 Token 就是 Token ，況且 JWT 要偽造是有可能的，一旦 Server 端的加密密鑰被破解，對方想怎麼偽造就怎麼偽造，這樣看來還比傳統的更不安全。</p><p>最後還有人覺得可以充當 Session ，這個是最嚴重的，<strong>千萬不要把 JWT 當作 Session 使用</strong>。</p><blockquote><p>Session 是由 Server 來保存 Client 狀態物件的機制，概念是把 SessionID 交給 Client 讓它每次請求都帶上，這樣 Server 就可以辨識出 Client 當前的狀態，許多購物車就是這樣實作</p></blockquote><p>因為 Session 有幾種問題存在：</p><ol><li>額外耗費 Server 資源（創建與管理 Session 物件）</li><li>分散式系統得處理 Session 共享與傳遞</li><li>只認 ID 可能導致被盜用身份</li></ol><p>但使用 JWT 不會使情況變好甚至更糟，光是前面提過的無法銷毀就比不上 Session ，雖然也許可以透過某些機制來處理，但除非時間很多我不會建議自己研究處理機制， Session 早已行之有年，上述的問題可能早存在一堆解法，不但有經過他人的實驗也有保障，絕對比起 JWT 更好。</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://jwt.io/" target="_blank" rel="noopener">JSON Web Token</a><br><a href="https://kylinyu.win/tags/jwt" target="_blank" rel="noopener">墨冊 - JWT</a><br><a href="https://blog.othree.net/log/2016/08/13/json-web-token/" target="_blank" rel="noopener">O3noBlog - JSON Web Token</a></p>]]></content>
      
      
      <categories>
          
          <category> 程式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 淺入淺出 </tag>
            
            <tag> jwt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>狗屎爛詞 Interface</title>
      <link href="/2019/12/05/term-interface/"/>
      <url>/2019/12/05/term-interface/</url>
      
        <content type="html"><![CDATA[<p>狗屎爛詞系列專門介紹業界常使用的術語或名詞，但會以我所理解的概念去解釋，故無法保證正確性<br>若有發現不理解或錯誤的部分請留言讓我知道，以便修正更改。</p><h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><p>介面（中國稱接口）屬於程式語言的一種特性，多數靜態語言都會有。</p><p>用專業點的說法是：「介面提供了<strong>抽象化</strong>的能力，可以<strong>隱藏</strong>底層的實作讓使用者專注於行為。」</p><p>介面是人們把「合約」或「規格」這種概念引入程式語言而產生，它本來就是我們生活中一項理所當然不過的事情，舉凡生活中處處可見的插座與插頭就是基於規格而生，下圖為 2018 的世界各地插座規格。</p><p><a href="https://www.statista.com/chart/13389/the-global-guide-to-plugging-in/" target="_blank" rel="noopener" title="Infographic: The Global Guide To Plugging In  | Statista"><img src="https://infographic.statista.com/normal/chartoftheday_13389_the_global_guide_to_plugging_in_n.jpg" alt="Infographic: The Global Guide To Plugging In  | Statista" width="100%" height="auto" style="width: 100%; height: auto !important; max-width:960px;-ms-interpolation-mode: bicubic;"/></a></p><p>台灣使用 Type-A 規格插座，這代表人在台灣只要有 Type-A 的插頭你就不怕用不了電。</p><h2 id="隱藏實作？"><a href="#隱藏實作？" class="headerlink" title="隱藏實作？"></a>隱藏實作？</h2><p>Implemet （實作）指的是製造符合介面定義的產物，介面允許了我們使用產品時不必在乎產品是什麼，這也是介面最大的優點。</p><p>假如現在要去英國，你會怎麼問插座的問題？</p><ol><li>「英國使用的是哪個廠商的插座？」</li><li>「英國使用的是哪個 Type 的插座？」</li></ol><p>正常情況都會選擇 2 的方式問，畢竟誰會特地調查要玩的地方插座由哪些供應商提供？</p><p>當有了規格，就很容易去應對會變化的未知，因為產品提供者不會只有一個，有時可能高達數百個。只要可以知道未知被侷限於某種限制，那就可以將其視為已知來應對，所以只要知道英國使用 Type-G 就可以只帶 Type-G 的轉接頭。</p><p>這也是介面提供抽象化能力的意思，因為每個實作都可能會有不同之處，只不過遵照著特定規格時就代表它們一定提供規格所指定的功能，不會出現號稱實作 Type-A 的插座卻插不了 Type-A 插頭的狀況。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SocketTypeA 規格 A 的插座</span></span><br><span class="line"><span class="keyword">type</span> SocketTypeA <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 規格為 A 的插座要能接受格式為 A 的插頭</span></span><br><span class="line">    Accept(plug PlugTypeA)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Jacky 供應商的插座實作 SocketTypeA 的介面（規格）</span></span><br><span class="line"><span class="keyword">type</span> JackySocket <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(socket JackySocket)</span> <span class="title">Accept</span><span class="params">(plug PlugTypeA)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Jacky 自己的實作，與其它供應商不一定一致</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Neko 供應商的插座實作 SocketTypeA 的介面（規格）</span></span><br><span class="line"><span class="keyword">type</span> NekoSocket <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(socket NekoSocket)</span> <span class="title">Accept</span><span class="params">(plug PlugTypeA)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Neko 自己的實作，與其它供應商不一定一致</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以不同團隊之間撰寫程式合作時，其實也能透過雙方約定好的介面來工作，這樣不論哪方都不必等另一方完成才能作業，介面讓工作於未知變得可行。（當然，最終在整合時出問題的機率還是有的）</p><h3 id="缺點"><a href="#缺點" class="headerlink" title="缺點"></a>缺點</h3><p>隱藏實作還是會造成一點問題，例如下圖。</p><p><img src="plugin-example.jpg" alt="插座例子"></p><p>上面的插座雖然有差別，但都可以插入 Type-A 的插頭，只是廠商 A 可能只要 30 分鐘就能充飽；廠商 B 花 2 小時不到一半，還燒斷電路。</p><p>因為實作被隱藏了，所以使用者在真正使用前無法得知結果是什麼，換句話說你可能插入插頭後發現：</p><ul><li>沒充電</li><li>電路燒壞</li><li>冒出火花</li><li>其它</li></ul><p>因為沒人能跟我們保證實作的正確性，所以人們習慣使用知名廠商的產品，比起聽都沒聽過的多數人都會買像是 Apple 、 Google 等大公司的產品，也就是更重視實作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Adder 提供加法的介面，確保一定有 Add 功能</span></span><br><span class="line"><span class="keyword">type</span> Adder <span class="keyword">interface</span> &#123;</span><br><span class="line">    Add(a, b <span class="keyword">int</span>) <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 優秀的實作會盡可能減少使用的資源與未知問題</span></span><br><span class="line"><span class="keyword">type</span> Good <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Good)</span> <span class="title">Add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 糟糕的實作可能會有一堆詭異的狀況，甚至沒辦法保證結果會跟你預期的一致</span></span><br><span class="line"><span class="keyword">type</span> Bad <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Bad)</span> <span class="title">Add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    doAdd = <span class="literal">true</span></span><br><span class="line">    a *= <span class="number">10</span></span><br><span class="line">    b *= <span class="number">10</span></span><br><span class="line">    tmp := (a + b) / <span class="number">10</span></span><br><span class="line">    cache[a][b] = tmp</span><br><span class="line">    <span class="keyword">return</span> tmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="介面的問題"><a href="#介面的問題" class="headerlink" title="介面的問題"></a>介面的問題</h2><p>介面可以將未知的變化侷限使得人可以應對，卻也導致了一件事情 ———— 介面太過穩定。</p><p>等等，穩定難道不是一件好事嗎？</p><p>當然是好事，穩定的系統才可能長久。只不過程式絕對不可能永遠穩定，正如一個系統永遠存在著變化一樣，這時介面可能會因變化造成難以想像的劇痛。</p><p>假設未來有一種特殊的規格，可以提供最優秀的效率與最安全的防護，但與現在的所有插座、插頭都不一樣該怎麼辦？</p><p>除了將現有的所有插座、插頭全都更改或銷毀以外沒有辦法，因為當初的介面已經定死規格，所以規格發生變化就會造成大量的改動，拿台灣 2300 萬人口來計算，最少也有 5 倍以上的插座與插頭存在，這是多可怕的數字應不用言喻。</p><p>程式當然也是如此，如果有一個存在很久的介面：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Connector 必須提供 Connect 的功能</span></span><br><span class="line"><span class="keyword">type</span> Connector <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 依據給予的帳號與密碼取得連線</span></span><br><span class="line">    Connect(username <span class="keyword">string</span>, password <span class="keyword">string</span>) *Connect</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有不少廠商們都依此介面提供自己的實作，結果有一天發現介面要增加功能：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Connector 必須提供 Connect 的功能</span></span><br><span class="line"><span class="keyword">type</span> Connector <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 依據給予的帳號與密碼取得連線</span></span><br><span class="line">    Connect(username <span class="keyword">string</span>, password <span class="keyword">string</span>) *Connect</span><br><span class="line">    <span class="comment">// 將傳入的連線解除連線狀態</span></span><br><span class="line">    Disconnect(conn *Connect) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我們先不討論這種改動和不合邏輯，當介面要加入新的功能或是方法就會造成<strong>所有</strong>實作毀壞，因為介面更改後原先的實作已不再符合規格。</p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>介面是程式語言將現實的規格概念引入的特性，提供了在未知情況下依然可以作業的能力，因為實作被隱藏後就不再是重點，可以專注於介面規格上，但太過穩定的介面會難以改動。</p>]]></content>
      
      
      <categories>
          
          <category> 程式 </category>
          
          <category> 狗屎爛詞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>淺入淺出 Redis</title>
      <link href="/2019/11/06/redis-intro/"/>
      <url>/2019/11/06/redis-intro/</url>
      
        <content type="html"><![CDATA[<p>Redis 可謂是當前最知名的 In-memory Database ，常常被拿來當快取資料庫。</p><p>由 C 語言撰寫的 Redis 為鍵值對（ Key - Value ）資料庫，資料皆儲存於 Memory 所以讀寫的速度非常快，只不過這導致 Redis 若不小心關閉，所有資料會直接消失。因此它也提供可選的持久化設定，開啟的話可以在某種程度上避免資料遺失。</p><p>可以想成 Redis 是一個獨立於程式外的高級 Map （或稱 Dict ），提供許多更進階的功能。</p><h2 id="Redis-特色？"><a href="#Redis-特色？" class="headerlink" title="Redis 特色？"></a>Redis 特色？</h2><p>Redis 採用單執行緒設計，雖然 4.0 之後有選擇多執行緒，但這不改變核心概念，那就是：『操作命令皆為單執行緒處理』。</p><h3 id="單執行緒？"><a href="#單執行緒？" class="headerlink" title="單執行緒？"></a>單執行緒？</h3><p>單執行緒最大的一個特點就是不必擔心<strong>資料競爭</strong>。</p><p>假如使用了多執行緒，為了避免競爭問題勢必得加入鎖（ Lock ）的機制，有經驗的人都很清楚這個機制要妥善處理有多麻煩吧？除了每次上鎖與解鎖的額外消耗，還得注意忘了取鎖、解鎖引發的問題。</p><p>此外， Redis 性能瓶頸不是來自於 CPU ，官方的 <a href="https://redis.io/topics/faq#redis-is-single-threaded-how-can-i-exploit-multiple-cpu--cores" target="_blank" rel="noopener" title="Redis is single threaded">FQA</a> 也說了：</p><blockquote><p>It’s not very frequent that CPU becomes your bottleneck with Redis, as usually Redis is either memory or network bound. For instance, using pipelining Redis running on an average Linux system can deliver even 1 million requests per second, so if your application mainly uses O(N) or O(log(N)) commands, it is hardly going to use too much CPU.</p></blockquote><p>即使在普通的 Linux 系統上啟動 Redis ，也能在 1sec 的時間內服務 1,000,000 個請求。</p><h3 id="引入多執行緒？"><a href="#引入多執行緒？" class="headerlink" title="引入多執行緒？"></a>引入多執行緒？</h3><p>確實在 4.0 版本中 Redis 引入多執行緒，這是因為後續加入了可異步處理的刪除操作。</p><table><thead><tr><th align="left">Async</th><th align="left">Sync</th></tr></thead><tbody><tr><td align="left">UNLINK</td><td align="left">DEL</td></tr><tr><td align="left">FLUSHALL ASYNC</td><td align="left">FLUSHALL</td></tr><tr><td align="left">FLUSHDB ASYNC</td><td align="left">FLUSHDB</td></tr></tbody></table><p>要刪除容量不大（ Memory Size ）的鍵值對不會花太多功夫，所以就算單執行緒<strong>同步地</strong>刪除也不太會阻塞到其它操作。</p><p>不過 Redis 也可能有巨型資料存在，動輒十幾 MB 或是幾百 MB 都可能，而這種龐大的資料不可能短時間內處理完，這樣會導致其它操作卡住。</p><p>異步版本的刪除命令，原理是先將 Key 給移除，而實際上 Value 的刪除則是透過其它執行緒來執行，這樣就可以在刪除大型資料時也不導致 Redis 卡住。</p><p>至於在 6.0 的多執行緒 I/O 主要是用來處理網路的讀寫，也就是實際上命令的執行依然維持在單執行緒。</p><h2 id="啟動與連線"><a href="#啟動與連線" class="headerlink" title="啟動與連線"></a>啟動與連線</h2><p>Redis 服務啟動時沒有傳入任何參數的話，預設會監聽 Port 6379 ，可以透過 <code>--port</code> 或是指定設定檔，但是設定檔要自己建立。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 透過參數指定 Port</span></span><br><span class="line">$ redis-server --port 6666</span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過設定檔</span></span><br><span class="line">$ redis-server redis.conf</span><br></pre></td></tr></table></figure><p>之後就可以藉由 redis-cli 來連線到 Redis ，直接執行時如果沒設定參數，會連向本地的 6379 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>要遠端連接需要透過 <code>-h</code> 指定 Host ； <code>-p</code> 指定 Port 。</p><h3 id="密碼"><a href="#密碼" class="headerlink" title="密碼"></a>密碼</h3><p>Redis 是可以設置密碼的，有兩種方式，分別是設定檔與操作命令。</p><p>設定檔只需要加入 <code>requirepass PASSWORD</code> 這段訊息，並在 Redis Server 啟動時指定使用該設定檔即可。</p><p>透過命令的話先連線至已啟動的 Redis Server ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先連線到 Redis Server</span></span><br><span class="line">$ redis-cli</span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的命令可以看目前密碼是否有設置</span></span><br><span class="line">127.0.0.1:6379&gt; CONFIG GET requirepass</span><br><span class="line">1) <span class="string">"requirepass"</span></span><br><span class="line">2) <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過 SET 來設置密碼（ requirepass ）</span></span><br><span class="line">127.0.0.1:6379&gt; CONFIG SET requirepass <span class="string">"PASSWORD"</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>當看到 OK 後如果在執行一次 GET 會出現錯誤訊息「 (error) NOAUTH Authentication required. 」，這樣就得透過認證命令來獲取權限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; AUTH <span class="string">"PASSWORD"</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>除了透過這種方式登入有設定密碼的 Redis ，也可以在執行 redis-cli 時透過 <code>-a</code> 來傳遞密碼：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -a PASSWORD</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>但這種方式並不推薦，原因在於 <code>-a</code> 送出的密碼會是明文傳遞，很容易被他人攔截到，所以大多情況還是建議使用 <code>AUTH</code> 命令來驗證。</p><blockquote><p>注意要移除密碼不是透過 <code>DEL</code> ，而是要透過 <code>SET</code> 將密碼設定為 “” （空字串）</p></blockquote><h3 id="設定檔"><a href="#設定檔" class="headerlink" title="設定檔"></a>設定檔</h3><p>Redis 啟動時都會使用一組設定檔，沒有指定時會使用預設值。</p><p>設定檔可以指定多種不同的資訊，如前述的密碼，或是開啟主從式架構的關係等，如果想知道當前的設定檔資訊，可以透過前綴 <code>CONFIG</code> 搭配 <code>GET</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 回傳的訊息中，奇數為設定的名稱；偶數為設定的值</span></span><br><span class="line">127.0.0.1:6379&gt; CONFIG GET *</span><br><span class="line">1) <span class="string">"dbfilename"</span></span><br><span class="line">2) <span class="string">"dump.rdb"</span></span><br><span class="line">3) <span class="string">"requirepass"</span></span><br><span class="line">4) <span class="string">""</span></span><br><span class="line">...</span><br><span class="line">213) <span class="string">"bind"</span></span><br><span class="line">214) <span class="string">""</span></span><br></pre></td></tr></table></figure><p>另外也能用 <code>INFO</code> 命令可以看當前 Redis 的相關資訊。</p><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><p>說起 Map 結構，其實核心操作不過就是 Get 與 Set 而已。</p><p>Redis 支援多種資料型態：</p><ol><li>String</li><li>List</li><li>Set</li><li>Hash</li><li>Sorted Set</li><li>Bitmap</li><li>HyperLogLog</li></ol><p>後面有兩個詭異的型態，但這邊先不介紹，通常我們會使用的應該只有前幾個，大部分的命令可以<a href="https://redis.io/commands" target="_blank" rel="noopener" title="Redis Commands">到此</a>查詢。</p><blockquote><p>上列表中沒有出現 Number / Numeric 型態，因為 Redis 會把值都會轉換成 String 儲存，因此部份與數字相關的操作（ <code>INCR</code> 、 <code>DECR</code> ），實際上都是先將其轉換為數字才處理</p></blockquote><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>可以透過 <code>SET</code> 設置指定 Key 與其相對的 Value （型態為 String ），也能藉由 <code>GET</code> 取出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 設定 name - Neko 鍵值對</span></span><br><span class="line">127.0.0.1:6379&gt; SET name <span class="string">"Neko"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 藉由 Key 取出對應的 Value</span></span><br><span class="line">127.0.0.1:6379&gt; GET name</span><br><span class="line"><span class="string">"Neko"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 讀取不存在的 Key 會收到 nil</span></span><br><span class="line">127.0.0.1:6379&gt; GET neko</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p>如果值不包含空白，可以不加入雙引號：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SET name Neko</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; GET name</span><br><span class="line">&quot;Neko&quot;</span><br></pre></td></tr></table></figure><p>當儲存的 Value 是可以被轉換成數字（ Integer 、 Float ），就可以使用數字相關的操作，好比說加減的 <code>INCR</code> 與 <code>DECR</code> （各自等於 <code>INCRBY 1</code> 與 <code>DECRBY 1</code> ）。</p><blockquote><p>如果增減的值屬於浮點數請改用 <code>INCRBYFLOAT</code> ，否則會出現型態轉換錯誤</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 設置數字的 Value</span></span><br><span class="line">127.0.0.1:6379&gt; SET num <span class="string">"1"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過 INCR 加一，會回傳加完後的值</span></span><br><span class="line">127.0.0.1:6379&gt; INCR num</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 想指定增加的值就需使用 INCRBY</span></span><br><span class="line">127.0.0.1:6379&gt; INCRBY num 3</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 減的操作相似，不用加上負號</span></span><br><span class="line">127.0.0.1:6379&gt; DECRBY num 3</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增減的值如果是 Float 就需用 INCRBYFLOAT （不論加或減）</span></span><br><span class="line">127.0.0.1:6379&gt; INCRBYFLOAT num 0.5</span><br><span class="line"><span class="string">"2.5"</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; INCRBYFLOAT num -0.5</span><br><span class="line"><span class="string">"2"</span></span><br></pre></td></tr></table></figure><p>注意，對於 <code>INCRBY</code> 與 <code>DECRBY</code> 命令的回傳值都會做 Integer 轉換，所以假使你的值為 Float ，那麼回傳值可能會出現錯誤「 (error) ERR value is not an integer or out of range 」。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SET f 0.5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 這種情況下會視為失敗，會保持原本的值</span></span><br><span class="line">127.0.0.1:6379&gt; INCR f</span><br><span class="line">(error) ERR value is not an <span class="built_in">integer</span> or out of range</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; GET f</span><br><span class="line"><span class="string">"0.5"</span></span><br></pre></td></tr></table></figure><p>也有命令可以一次存取多個鍵值對，這些命令前方會多 M （ <code>MSET</code> 、 <code>MGET</code> ），用法基本上是沒有差別的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 透過空白隔離多個鍵值對</span></span><br><span class="line">127.0.0.1:6379&gt; MSET name <span class="string">"Doge"</span> age <span class="string">"66"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取出時會依照輸入 Key 的順序</span></span><br><span class="line">127.0.0.1:6379&gt; MGET age name</span><br><span class="line">1) <span class="string">"66"</span></span><br><span class="line">2) <span class="string">"Doge"</span></span><br></pre></td></tr></table></figure><p>Redis 在設值時有提供多種方式，可以在特定條件下才設值。<br>原本這些命令都被拆分開來，但在 2.6.12 時可以透過 <code>SET</code> 參數方式使用。</p><table><thead><tr><th align="left">Command</th><th align="left">Option</th><th align="center">Desc</th></tr></thead><tbody><tr><td align="left">SETEX</td><td align="left">EX</td><td align="center">指定過期時間，到了以後會移除（ second ）</td></tr><tr><td align="left">PSETEX</td><td align="left">PX</td><td align="center">指定過期時間，到了以後會移除（ millisecond ）</td></tr><tr><td align="left">SETNX</td><td align="left">NX</td><td align="center">當 Key 不存在時才設值</td></tr><tr><td align="left">-</td><td align="left">XX</td><td align="center">當 Key 存在時才設值</td></tr></tbody></table><p>透過參數形式的好處是可以混合多種 Option ，好比說我希望在沒有 Key 時設值，且這個值有效時間只有 10 秒，這種情況只能透過 Option 的方式設定。</p><blockquote><p>官方已不再建議使用 Command 形式，上面的三個命令可能會在未來被移除</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下方兩種方式結果是一樣的</span></span><br><span class="line">127.0.0.1:6379&gt; SET secret <span class="string">"abc123"</span> EX 10</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SETEX secret 10 <span class="string">"abc123"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 混合 Option 當 Key 不存在才設值且有效時間為 5 秒</span></span><br><span class="line">127.0.0.1:6379&gt; SET secret <span class="string">"abc123"</span> NX EX 5</span><br></pre></td></tr></table></figure><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>Redis 的 List 是單純的 String List ，使用時可以將元素放入頭或尾。<br>其實就是 Linked List ，據官方的說明可以儲存 2^32 - 1 個元素（ 4,294,967,295 ）。</p><p>增加元素時會確認是否已存在 List ，不存在時會自動建立，而透過命令移除元素時如果會使 List 為空，則會移除該 Key 。</p><blockquote><p>意思是如果 List 被清空，那麼等於此 Key 沒被設置過</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 元素放入的方式有左與右（ LPUSH 、 RPUSH ），並回傳當前 List 長度</span></span><br><span class="line">127.0.0.1:6379&gt; LPUSH nums <span class="string">"10"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; RPUSH nums <span class="string">"20"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># LRANGE 可以取出指定 Key 的 Start Index 到 End Index 的值</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE nums 0 -1</span><br><span class="line">1) <span class="string">"10"</span></span><br><span class="line">2) <span class="string">"20"</span></span><br></pre></td></tr></table></figure><p>Index 的部分支援逆向，所以例子的 -1 意思是倒數最後一個元素，整條命令就是取出 List 上所有元素。</p><p>取出元素可以基於 Index 或是如 Queue 一樣在取值時會將其移出 List ，前者就如同程式語言內常用的 List[Index] 操作；後者則是 Queue 的 Pop 操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下會建立出 [10, 20, 30] 的陣列</span></span><br><span class="line">127.0.0.1:6379&gt; RPUSH nums <span class="string">"10"</span> <span class="string">"20"</span> <span class="string">"30"</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基於 Index 取值，但不會移出 List</span></span><br><span class="line">127.0.0.1:6379&gt; LINDEX nums 0</span><br><span class="line"><span class="string">"10"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 從左取出第一個元素，並移出 List</span></span><br><span class="line">127.0.0.1:6379&gt; LPOP nums</span><br><span class="line"><span class="string">"10"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 從右取出第一個元素，並移出 List</span></span><br><span class="line">127.0.0.1:6379&gt; RPOP nums</span><br><span class="line"><span class="string">"30"</span></span><br></pre></td></tr></table></figure><p>Pop 相關的操作還有提供 Block 版本，表示如果 Pop 的對象沒有任何元素可以取出，那麼連線將 Block 直到有元素可以回傳或超時。</p><p>命令需給予超時時限（ second ），但如果給 0 則表示無限制。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果 nums 左有元素可以取出，則效果同 LPOP 否則會卡在此處直到有元素可回傳或 30 秒後</span></span><br><span class="line">127.0.0.1:6379&gt; BLPOP nums 30</span><br><span class="line">(nil)</span><br><span class="line">(30.9s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有元素的情況就如同一般 POP</span></span><br><span class="line">127.0.0.1:6379&gt; LPUSH nums <span class="string">"1"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; BLPOP nums 30</span><br><span class="line"><span class="string">"1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以一次 Block 監聽多個 Key 有沒有元素，會回傳第一個不為空的元素</span></span><br><span class="line">127.0.0.1:6379&gt; BLPOP nums names ages 30</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>單執行緒的 Redis 在處理 Block 時，會透過 Dict 來儲存 Key 與等待者的資訊，好比說 ClientID 。並在每次處理命令時都檢查是否有元素可以提供。</p><p>當然如果是這樣會導致每次跑命令都浪費時間，所以 Redis 利用兩個 Dict 來記錄，名稱分別為 <strong>blocking_keys</strong> 與 <strong>ready_keys</strong> 。</p><ul><li>blocking_keys<br>  為 Key : List&lt;Client&gt; 的 Dict ，記錄著有人等待的 Key 與等待者相關訊息。</li><li>ready_keys<br>  當 Push 的 Key 為空 List 時會檢查該 Key 是否存在於 blocking_keys 內，有的話會將相關訊息放入 ready_keys ，也是每次 Redis 處理命令時會檢查的對象。</li></ul><p>所以實際上只有在處理 Push 相關訊息時才會檢查 Block 名單，如果該 key 剛好在 Block 名單中就透過 Ready 名單通知 Server 與 Client 。</p><blockquote><p>在 <code>MULTI</code> / <code>EXEC</code> 中使用 Block 的命令，會因為交易原子性問題馬上回應，效用等同於非 Block 操作</p></blockquote><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Redis 的 Set 為無序的 String 集合，據官方所說可儲存的數量與 List 同樣為 2^32 - 1 個（ 4,294,967,295 ）。</p><p>與常見的 Set 結構一樣，內部的元素是不允許重複的。</p><p>透過 <code>SADD</code> 可以替 Set 放入元素，要是想確認某個元素是否存在於 Set 需要透過 <code>SISMEMBER</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SADD 可以一次放入多樣值，回傳 Set 操作後的元素數量</span></span><br><span class="line">127.0.0.1:6379&gt; SADD unique <span class="string">"Neko"</span> <span class="string">"Doge"</span> <span class="string">"Neko"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢查指定元素是否存在，回傳 Integer 存在為 1 ；不存在為 0</span></span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER unique <span class="string">"Neko"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER unique <span class="string">"Jacky"</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><p>移除 Set 內的資料可以透過 <code>SPOP</code> 與 <code>SREM</code> ，<br>但前者是<strong>隨機地</strong>移除指定 Set 的元素，後者才可以指定移除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SADD unique <span class="string">"A"</span> <span class="string">"B"</span> <span class="string">"C"</span> <span class="string">"D"</span> <span class="string">"E"</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 隨機移除兩個元素，數量省略時預設為 1</span></span><br><span class="line">127.0.0.1:6379&gt; SPOP unique 2</span><br><span class="line">1) <span class="string">"B"</span></span><br><span class="line">2) <span class="string">"D"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除指定元素， 2.4 之後可以一次移除多個，會回傳被移除的數量</span></span><br><span class="line">127.0.0.1:6379&gt; SREM unique <span class="string">"A"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假使移除不存在的元素也可以，但不會包含在移除數量中</span></span><br><span class="line">127.0.0.1:6379&gt; SREM unique <span class="string">"A"</span> <span class="string">"B"</span> <span class="string">"C"</span> <span class="string">"D"</span> <span class="string">"E"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure><p>如果想確認 Set 目前的數量可以用 <code>SCARD</code> ，不過想知道目前裡面所有的元素內容就得透過 <code>SMEMBERS</code> 。後者的速度比較慢，以時間複雜度來說前者為 O(1) 後者為 O(N) 。</p><p>Set 本身也有比較進階的操作，好比說交集（ <code>SINTER</code> ）、聯集（ <code>SUNION</code> ）、差集（ <code>SDIFF</code> ）等，除了聯集以外，另外兩個都是以第一個 Set 為基礎去處理，而非把每個 Set 都視為平等。</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>Hash 就是鍵值皆為 String 的 Map 結構，也因此很適合用來模擬 Object 。當然，據官方所說 Hash 同樣可以儲存 2^32 - 1 組鍵值對。</p><p>以一個 JSON 物件來當例子可以更好理解 Hash 如何模擬物件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"Neko"</span>,</span><br><span class="line">    <span class="attr">"age"</span>: <span class="number">66</span>,</span><br><span class="line">    <span class="attr">"level"</span>: <span class="string">"normal"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述為擁有編號、名稱、等級等資訊的 User 物件，透過 <code>HSET</code> 來設置這個物件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 設置成功後會回傳成功加入的鍵值對數量</span></span><br><span class="line">127.0.0.1:6379&gt; HSET user:100 id 100</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.0 之後 HSET 允許一次設定多組鍵值對</span></span><br><span class="line">127.0.0.1:6379&gt; HSET user:100 name <span class="string">"Neko"</span> age 66 level <span class="string">"normal"</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.0 之前要設定多組得透過 HMSET</span></span><br><span class="line">127.0.0.1:6379&gt; HMSET user:100 name <span class="string">"Neko"</span> age 66 level <span class="string">"normal"</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><p>回傳的值是被<strong>新加入</strong>的鍵值對數量，換句話說修改是不包含在內的，這種情況會收到 0 。</p><blockquote><p>Redis 建議命名 Key 時如果有不同區段訊息，應該透過 <code>:</code> 來區隔而不是 <code>_</code></p></blockquote><p>雖說上面的例子是模擬 Object ，但是身為 Map 結構該有的操作都沒少，例如讀取某個 Key 對應的 Value ，或取出目前所有 Key 、 Value 等命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 單獨取用某個 Key 的值</span></span><br><span class="line">127.0.0.1:6379&gt; HGET user:100 name</span><br><span class="line"><span class="string">"Neko"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只取出對象目前所有的 Key</span></span><br><span class="line">127.0.0.1:6379&gt; HKEYS user:100</span><br><span class="line">1) <span class="string">"id"</span></span><br><span class="line">2) <span class="string">"name"</span></span><br><span class="line">3) <span class="string">"age"</span></span><br><span class="line">4) <span class="string">"level"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只取出對象目前所有的 Value</span></span><br><span class="line">127.0.0.1:6379&gt; HVALS user:100</span><br><span class="line">1) <span class="string">"100"</span></span><br><span class="line">2) <span class="string">"Neko"</span></span><br><span class="line">3) <span class="string">"66"</span></span><br><span class="line">4) <span class="string">"normal"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把全部鍵值對都取出來，奇數為 Key ；偶數為 Value</span></span><br><span class="line">127.0.0.1:6379&gt; GETALL user:100</span><br><span class="line">1) <span class="string">"id"</span></span><br><span class="line">2) <span class="string">"100"</span></span><br><span class="line">3) <span class="string">"name"</span></span><br><span class="line">4) <span class="string">"Neko"</span></span><br><span class="line">5) <span class="string">"age"</span></span><br><span class="line">6) <span class="string">"66"</span></span><br><span class="line">7) <span class="string">"level"</span></span><br><span class="line">8) <span class="string">"normal"</span></span><br></pre></td></tr></table></figure><p>如果要移除 Hash 的某組鍵值對，需要透過 <code>HDEL</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 移除時會回傳成功移除掉的鍵值對數量</span></span><br><span class="line">127.0.0.1:6379&gt; HDEL user:100 name</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 2.4 版之後可以一次移除多個</span></span><br><span class="line">127.0.0.1:6379&gt; HDEL user:100 id age level</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><p>如果 Hash 只儲存少數 Fields （一百個左右），只會佔用很小的空間，也就是說即使是一個微小的 Redis Server 也可以用來儲存百萬個 Object 而不用擔心。</p><h3 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h3><p>可排序的 Set ，<br>對，就這樣，連原理都蠻單純的。</p><p>Sorted Set 在儲存資料時會對應到一個分數（ Score ），這個分數就是拿來做排序的關鍵，排序上通常會以低 -&gt; 高。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一般的 Set</span></span><br><span class="line">127.0.0.1:6379&gt; SADD <span class="built_in">set</span>:normal <span class="string">"Neko"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可排序的 Set</span></span><br><span class="line">127.0.0.1:6379&gt; ZADD <span class="built_in">set</span>:sorted 1 <span class="string">"Neko"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><p>雖然 Set 結構不允許出現重複的元素，但是分數是可以重複的，官方對於分數重複的描述為：</p><blockquote><p>While the same element can’t be repeated in a sorted set since every element is unique, it is possible to add multiple different elements having the same score. When multiple elements have the same score, they are ordered lexicographically (they are still ordered by score as a first key, however, locally, all the elements with the same score are relatively ordered lexicographically).</p></blockquote><p>當分數一致時，會透過位元排序，也就是會將 String 視為 Byte Array 來做比對。</p><p>Sorted Set 除了最基礎的 Set 操作，還有許多獨自擁有的，例如說檢查某個元素當前排名 <code>ZRANK</code> ，查看指定元素目前的分數的 <code>ZSCORE</code> 等。</p><p>Sorted Set 有排序的關係，取出存在的元素不是 <code>ZMEMBERS</code> ，而是要改用 <code>ZRANGE</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZADD sorted 1 <span class="string">"A"</span> 2 <span class="string">"B"</span> 3 <span class="string">"C"</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此處的 0 與 -1 是表示排名，也就是第一名到最後一名全部顯示</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGE sorted 0 -1</span><br><span class="line">1) <span class="string">"A"</span></span><br><span class="line">2) <span class="string">"B"</span></span><br><span class="line">3) <span class="string">"C"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想一併知道分數，可以透過給予 WITHSCORES 參數</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGE sorted 0 -1 WITHSOCRES</span><br><span class="line">1) <span class="string">"A"</span></span><br><span class="line">2) <span class="string">"1"</span></span><br><span class="line">3) <span class="string">"B"</span></span><br><span class="line">4) <span class="string">"2"</span></span><br><span class="line">5) <span class="string">"C"</span></span><br><span class="line">6) <span class="string">"3"</span></span><br></pre></td></tr></table></figure><p>也可以透過可排序功能與 Pop 操作，來對任務做權重分配，例如新增會員 Score = 1 而修改會員資料 Score = 3 ，配置對應的 Worker 來取出目前等待中的任務。</p><p>但這樣處理時需要注意，假如進來的任務全都是權重高的，就會變成權重低的任務一直沒有處理的情況。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 透過 Block 系列的 Pop 來等待任務， MIN 指的是 Score 最小的</span></span><br><span class="line">127.0.0.1:6379&gt; BZPOPMIN events 0</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先建立一個 Sorted Set</span></span><br><span class="line">127.0.0.1:6379&gt; ZADD tasks 1 <span class="string">"create"</span> 2 <span class="string">"modify"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一樣可以監聽多個 Key ，成功收到後的訊息為三個 Key, Value, Score</span></span><br><span class="line">127.0.0.1:6379&gt; BZPOPMIN events tasks 0</span><br><span class="line">1) <span class="string">"tasks"</span></span><br><span class="line">2) <span class="string">"create"</span></span><br><span class="line">3) <span class="string">"1"</span></span><br></pre></td></tr></table></figure><p>Block 相關的原理請參考 <a href="#List">List</a> 末段 Block 操作。</p><h2 id="事務"><a href="#事務" class="headerlink" title="事務"></a>事務</h2><p>Transaction 是個術語，意思是操作是否能提供 <a href="https://zh.wikipedia.org/wiki/ACID" target="_blank" rel="noopener">ACID</a> 特性。</p><p>這種需求通常跟交易有關，譬如轉賬是從 A 帳戶轉移金錢到 B 帳戶，雖然看起來只需要兩步驟：</p><ol><li>A 扣錢</li><li>B 加錢</li></ol><p>但這涉及到操作的不安全性就沒這麼簡單。</p><p>好比說 A 已經扣除 1000$ ，但這時幫 B 增加 1000$ 失敗呢？會變成 A 損失 1000$ ，<br>又好比 A 扣錢失敗，但 B 卻成功增加 1000$ 。</p><p>Redis 提供了開始事務的 <code>MULTI</code> 與執行事務的 <code>EXEC</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先設置帳戶 A 與帳戶 B 的金額（各 5000 ）</span></span><br><span class="line">127.0.0.1:6379&gt; HSET bank:a money 5000</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; HSET bank:b money 5000</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 開始事務，此命令永遠都會回傳 OK</span></span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將帳戶 A 的金額扣除 1000 的操作加入事務中</span></span><br><span class="line">127.0.0.1:6379&gt; HINCRBY bank:a money -1000</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將帳戶 B 的金額增加 1000 的操作加入事務中</span></span><br><span class="line">127.0.0.1:6379&gt; HINCRBY bank:b money 1000</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"><span class="comment"># 執行事務中的操作，會回傳每個操作的結果</span></span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">1) (<span class="built_in">integer</span>) 4000</span><br><span class="line">2) (<span class="built_in">integer</span>) 6000</span><br></pre></td></tr></table></figure><p>但是與大多數人理解的事務不同的是， Redis 透過 <code>MULTI</code> / <code>EXEC</code> 的操作只能保持原子性，卻無法保持成功一同成功，失敗一同失敗，因為它不具有 Roll Back （回朔）功能。</p><p>換句話說依然可能存在 A 扣款 B 沒入款的情況，而 Redis 之所以不支援 Roll Back 的原因有二：</p><ol><li>Redis 命令失敗的情況只有錯誤的語法使用（且無法於 QUEUED 時發現），這種情況屬於程式邏輯錯誤，不應該出現在生產環境中</li><li>因為不支援 Roll Back 可以使 Redis 保持簡單與快速</li></ol><p>即使如此 Redis 也提供 <code>WATCH</code> 命令以確保與程式搭配時的 Check-And-Set （ CAS ）行為，透過 <code>WATCH</code> 可以監視指定的 Keys 是否有被更改過，如果被更改會會導致 Transaction 執行失敗。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># WATCH 必須在 MULTI 前使用</span></span><br><span class="line">127.0.0.1:6379&gt; WATCH counter</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 開始事務</span></span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把 counter 增加 1</span></span><br><span class="line">127.0.0.1:6379&gt; INCR counter</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"><span class="comment"># 執行事務，此時假設有其它 Client 修改過 counter ，回應會收到 nil</span></span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p>很明顯是種樂觀鎖，等於對事務執行設置了前置條件，以沒人改變監視的 Keys 為依據。</p><p>使用 <code>WATCH</code> 時要小心，一旦碰上 <code>EXEC</code> 與 <code>DISCARD</code> 都會取消目前所有監視的 Keys ，因為前者是執行事務後者則是放棄事務。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>實際上使用 <code>MULTI</code> 時會改變 Client 端的模式，也就是轉換為事務模式。</p><p>當處在事務模式的 Client 只要不執行 <code>EXEC</code> 、 <code>DISCARD</code> 都不會取消事務模式，這個模式中的所有命令都會被保存在一個 Queue 內，並回應訊息 『 QUEUED 』。</p><p>當執行 <code>EXEC</code> 後會將 Queue 內的命令傳送給 Server ，它便會依照順序依次執行與記錄結果，最終將事務的結果回傳給 Client 。</p><h3 id="Lua-Script"><a href="#Lua-Script" class="headerlink" title="Lua Script"></a>Lua Script</h3><p>2.6 時 Redis 引入了 Lua 執行環境，也就是 2.6 版本之後就內建一個 Lua 的 Interpreter ，而 <a href="https://www.lua.org/" target="_blank" rel="noopener">Lua</a> 是一個極輕量的語言，它的目標是成為最容易嵌入其它語言的程式語言。</p><p>Redis 對於 Lua 的環境做了許多修改，以避免產生漏洞遭利用，此外也提供由 Lua 呼叫 Redis 命令的函式等。並且為了支援持久化功能， Redis 限制了 Lua 函式必須符合三點：</p><ol><li>沒有副作用</li><li>沒有有害的隨機性（比如隨機寫一個鍵值對）</li><li>同樣的輸入必得出同樣的結果</li></ol><p>Redis 保證了 Lua 的原子性，也就是當執行 Lua Script 時不會在中間執行其它 Lua Script 或 Redis Command 。</p><p>換句話說 Lua Script 本身就是一種 Transaction ，而且還比原本 <code>MULTI</code> / <code>EXEC</code> 更快更簡單。官方雖然短時間內不會移除舊版本的事務機制，但假使未來的使用者都傾向使用 Lua Script 來處理的話，最終可能會把舊有機制給移除。</p><p>我自己感覺 Lua Script 提供更多功能與靈活性，若沒特殊原因應該也會選擇 Lua ，但這邊不會再詳細介紹 Lua ，可能未來會找時間寫相關的雜學。</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://redis.io/" target="_blank" rel="noopener" title="官方網站">Redis</a></li><li><a href="https://draveness.me/whys-the-design-redis-single-thread" target="_blank" rel="noopener" title="面向信仰编程">为什么 Redis 选择单线程模型 · Why’s THE Design?</a></li><li><a href="http://redisbook.com/index.html" target="_blank" rel="noopener">Redis 设计与实现</a></li><li><a href="https://www.jianshu.com/p/xsMzfn" target="_blank" rel="noopener" title="简书">Redis阻塞操作实现原理</a></li><li><a href="http://redisdoc.com/index.html" target="_blank" rel="noopener">Redis 命令参考</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 程式 </category>
          
          <category> 資料庫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 淺入淺出 </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/10/29/hello-world/"/>
      <url>/2019/10/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Hello World</p><p>雖說原先累積了三頁左右的雜學，但因考量到幾年前的寫作方式與近乎照抄的內容，還是決定重來，果然大清除的時候對於不需要的東西要直接捨棄才好啊。</p><p>這次的 Blog 變動其實有想趁機改成用其它 Framework ，好比說 Hugo 、 Jekyll 這種，前者是 Go 語言寫的，優點是編譯速度非常快且我也比較熟悉；後者是 Ruby ，優點的話想不太到所以沒掙扎很久，雖然我有朋友大力推薦這門語言，但對它一直沒感覺。</p><p>但最終還是用 Hexo ，其一是想藉此學學放很久的前端技能，其二我真的蠻喜歡這個主題，想到換成別的又得重新找就覺得很累，以上。</p><h2 id="Hello-World-？"><a href="#Hello-World-？" class="headerlink" title="Hello World ？"></a>Hello World ？</h2><p>原本是想就這樣結束，但又覺得啥東西都沒有也怪怪的，所以來補充個學程式語言時最常見的例子『 Hello World 』吧。</p><p>這個範例知名到 <a href="https://wikipedia.org/wiki/Hello_World" target="_blank" rel="noopener">Wiki</a> 有專門的頁面，就連日本在 2019-09-20 都上映了<a href="https://hello-world-movie.com/index.html" target="_blank" rel="noopener">同名電影</a>。</p><p>依據 Wiki 中所述這是在 B 語言的文件《 A Tutorial Introduction to the Language B 》提到的 Hello World 例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">  extrn a,b,c;</span><br><span class="line">  putchar(a); putchar(b); putchar(c); putchar(&apos;!*n&apos;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">a &apos;hell&apos;;</span><br><span class="line">b &apos;o, w&apos;;</span><br><span class="line">c &apos;orld&apos;;</span><br></pre></td></tr></table></figure><p>這類例子的用意很單純，因為基本上是最簡單的程式，所以適合用來介紹語言特性，比如上面就能看到 B 語言的某些特性。<br>而這位作者後來與他人共同開發知名的 C 語言，教學中舉的例子也是 Hello World ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello, world\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有多少高手的第一個語言是 C 呢？絕對多到你數不清。</p><p>所以根據人的惰性與習慣，這些人後來在撰寫教學文件時，第一個例子想到 Hello World 就一點也不奇怪了。</p>]]></content>
      
      
      <categories>
          
          <category> 雜七雜八 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
