<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>狗屎爛詞 Interface</title>
      <link href="/2019/12/05/term-interface/"/>
      <url>/2019/12/05/term-interface/</url>
      
        <content type="html"><![CDATA[<p>狗屎爛詞系列專門介紹業界常使用的術語或名詞，但會以我所理解的概念去解釋，故無法保證正確性<br>若有發現不理解或錯誤的部分請留言讓我知道，以便修正更改。</p><h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><p>介面（中國稱接口）屬於程式語言的一種特性，多數靜態語言都會有。</p><p>用專業點的說法是：「介面提供了<strong>抽象化</strong>的能力，可以<strong>隱藏</strong>底層的實作讓使用者專注於行為。」</p><p>介面是人們把「合約」或「規格」這種概念引入程式語言而產生，它本來就是我們生活中一項理所當然不過的事情，舉凡生活中處處可見的插座與插頭就是基於規格而生，下圖為 2018 的世界各地插座規格。</p><p><a href="https://www.statista.com/chart/13389/the-global-guide-to-plugging-in/" target="_blank" rel="noopener" title="Infographic: The Global Guide To Plugging In  | Statista"><img src="https://infographic.statista.com/normal/chartoftheday_13389_the_global_guide_to_plugging_in_n.jpg" alt="Infographic: The Global Guide To Plugging In  | Statista" width="100%" height="auto" style="width: 100%; height: auto !important; max-width:960px;-ms-interpolation-mode: bicubic;"/></a></p><p>台灣使用 Type-A 規格插座，這代表人在台灣只要有 Type-A 的插頭你就不怕用不了電。</p><h2 id="隱藏實作？"><a href="#隱藏實作？" class="headerlink" title="隱藏實作？"></a>隱藏實作？</h2><p>Implemet （實作）指的是製造符合介面定義的產物，介面允許了我們使用產品時不必在乎產品是什麼，這也是介面最大的優點。</p><p>假如現在要去英國，你會怎麼問插座的問題？</p><ol><li>「英國使用的是哪個廠商的插座？」</li><li>「英國使用的是哪個 Type 的插座？」</li></ol><p>正常情況都會選擇 2 的方式問，畢竟誰會特地調查要玩的地方插座由哪些供應商提供？</p><p>當有了規格，就很容易去應對會變化的未知，因為產品提供者不會只有一個，有時可能高達數百個。只要可以知道未知被侷限於某種限制，那就可以將其視為已知來應對，所以只要知道英國使用 Type-G 就可以只帶 Type-G 的轉接頭。</p><p>這也是介面提供抽象化能力的意思，因為每個實作都可能會有不同之處，只不過遵照著特定規格時就代表它們一定提供規格所指定的功能，不會出現號稱實作 Type-A 的插座卻插不了 Type-A 插頭的狀況。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SocketTypeA 規格 A 的插座</span></span><br><span class="line"><span class="keyword">type</span> SocketTypeA <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 規格為 A 的插座要能接受格式為 A 的插頭</span></span><br><span class="line">    Accept(plug PlugTypeA)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Jacky 供應商的插座實作 SocketTypeA 的介面（規格）</span></span><br><span class="line"><span class="keyword">type</span> JackySocket <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(socket JackySocket)</span> <span class="title">Accept</span><span class="params">(plug PlugTypeA)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Jacky 自己的實作，與其它供應商不一定一致</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Neko 供應商的插座實作 SocketTypeA 的介面（規格）</span></span><br><span class="line"><span class="keyword">type</span> NekoSocket <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(socket NekoSocket)</span> <span class="title">Accept</span><span class="params">(plug PlugTypeA)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Neko 自己的實作，與其它供應商不一定一致</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以不同團隊之間撰寫程式合作時，其實也能透過雙方約定好的介面來工作，這樣不論哪方都不必等另一方完成才能作業，介面讓工作於未知變得可行。（當然，最終在整合時出問題的機率還是有的）</p><h3 id="缺點"><a href="#缺點" class="headerlink" title="缺點"></a>缺點</h3><p>隱藏實作還是會造成一點問題，例如下圖。</p><p><img src="plugin-example.jpg" alt="插座例子"></p><p>上面的插座雖然有差別，但都可以插入 Type-A 的插頭，只是廠商 A 可能只要 30 分鐘就能充飽；廠商 B 花 2 小時不到一半，還燒斷電路。</p><p>因為實作被隱藏了，所以使用者在真正使用前無法得知結果是什麼，換句話說你可能插入插頭後發現：</p><ul><li>沒充電</li><li>電路燒壞</li><li>冒出火花</li><li>其它</li></ul><p>因為沒人能跟我們保證實作的正確性，所以人們習慣使用知名廠商的產品，比起聽都沒聽過的多數人都會買像是 Apple 、 Google 等大公司的產品，也就是更重視實作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Adder 提供加法的介面，確保一定有 Add 功能</span></span><br><span class="line"><span class="keyword">type</span> Adder <span class="keyword">interface</span> &#123;</span><br><span class="line">    Add(a, b <span class="keyword">int</span>) <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 優秀的實作會盡可能減少使用的資源與未知問題</span></span><br><span class="line"><span class="keyword">type</span> Good <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Good)</span> <span class="title">Add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 糟糕的實作可能會有一堆詭異的狀況，甚至沒辦法保證結果會跟你預期的一致</span></span><br><span class="line"><span class="keyword">type</span> Bad <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Bad)</span> <span class="title">Add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    doAdd = <span class="literal">true</span></span><br><span class="line">    a *= <span class="number">10</span></span><br><span class="line">    b *= <span class="number">10</span></span><br><span class="line">    tmp := (a + b) / <span class="number">10</span></span><br><span class="line">    cache[a][b] = tmp</span><br><span class="line">    <span class="keyword">return</span> tmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="介面的問題"><a href="#介面的問題" class="headerlink" title="介面的問題"></a>介面的問題</h2><p>介面可以將未知的變化侷限使得人可以應對，卻也導致了一件事情 ———— 介面太過穩定。</p><p>等等，穩定難道不是一件好事嗎？</p><p>當然是好事，穩定的系統才可能長久。只不過程式絕對不可能永遠穩定，正如一個系統永遠存在著變化一樣，這時介面可能會因變化造成難以想像的劇痛。</p><p>假設未來有一種特殊的規格，可以提供最優秀的效率與最安全的防護，但與現在的所有插座、插頭都不一樣該怎麼辦？</p><p>除了將現有的所有插座、插頭全都更改或銷毀以外沒有辦法，因為當初的介面已經定死規格，所以規格發生變化就會造成大量的改動，拿台灣 2300 萬人口來計算，最少也有 5 倍以上的插座與插頭存在，這是多可怕的數字應不用言喻。</p><p>程式當然也是如此，如果有一個存在很久的介面：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Connector 必須提供 Connect 的功能</span></span><br><span class="line"><span class="keyword">type</span> Connector <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 依據給予的帳號與密碼取得連線</span></span><br><span class="line">    Connect(username <span class="keyword">string</span>, password <span class="keyword">string</span>) *Connect</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有不少廠商們都依此介面提供自己的實作，結果有一天發現介面要增加功能：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Connector 必須提供 Connect 的功能</span></span><br><span class="line"><span class="keyword">type</span> Connector <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 依據給予的帳號與密碼取得連線</span></span><br><span class="line">    Connect(username <span class="keyword">string</span>, password <span class="keyword">string</span>) *Connect</span><br><span class="line">    <span class="comment">// 將傳入的連線解除連線狀態</span></span><br><span class="line">    Disconnect(conn *Connect) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我們先不討論這種改動和不合邏輯，當介面要加入新的功能或是方法就會造成<strong>所有</strong>實作毀壞，因為介面更改後原先的實作已不再符合規格。</p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>介面是程式語言將現實的規格概念引入的特性，提供了在未知情況下依然可以作業的能力，因為實作被隱藏後就不再是重點，可以專注於介面規格上，但太過穩定的介面會難以改動。</p>]]></content>
      
      
      <categories>
          
          <category> 程式 </category>
          
          <category> 狗屎爛詞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>淺入淺出 Redis</title>
      <link href="/2019/11/06/redis-intro/"/>
      <url>/2019/11/06/redis-intro/</url>
      
        <content type="html"><![CDATA[<p>Redis 可謂是當前最知名的 In-memory Database ，常常被拿來當快取資料庫。</p><p>由 C 語言撰寫的 Redis 為鍵值對（ Key - Value ）資料庫，資料皆儲存於 Memory 所以讀寫的速度非常快，只不過這導致 Redis 若不小心關閉，所有資料會直接消失。因此它也提供可選的持久化設定，開啟的話可以在某種程度上避免資料遺失。</p><p>可以想成 Redis 是一個獨立於程式外的高級 Map （或稱 Dict ），提供許多更進階的功能。</p><h2 id="Redis-特色？"><a href="#Redis-特色？" class="headerlink" title="Redis 特色？"></a>Redis 特色？</h2><p>Redis 採用單執行緒設計，雖然 4.0 之後有選擇多執行緒，但這不改變核心概念，那就是：『操作命令皆為單執行緒處理』。</p><h3 id="單執行緒？"><a href="#單執行緒？" class="headerlink" title="單執行緒？"></a>單執行緒？</h3><p>單執行緒最大的一個特點就是不必擔心<strong>資料競爭</strong>。</p><p>假如使用了多執行緒，為了避免競爭問題勢必得加入鎖（ Lock ）的機制，有經驗的人都很清楚這個機制要妥善處理有多麻煩吧？除了每次上鎖與解鎖的額外消耗，還得注意忘了取鎖、解鎖引發的問題。</p><p>此外， Redis 性能瓶頸不是來自於 CPU ，官方的 <a href="https://redis.io/topics/faq#redis-is-single-threaded-how-can-i-exploit-multiple-cpu--cores" target="_blank" rel="noopener" title="Redis is single threaded">FQA</a> 也說了：</p><blockquote><p>It’s not very frequent that CPU becomes your bottleneck with Redis, as usually Redis is either memory or network bound. For instance, using pipelining Redis running on an average Linux system can deliver even 1 million requests per second, so if your application mainly uses O(N) or O(log(N)) commands, it is hardly going to use too much CPU.</p></blockquote><p>即使在普通的 Linux 系統上啟動 Redis ，也能在 1sec 的時間內服務 1,000,000 個請求。</p><h3 id="引入多執行緒？"><a href="#引入多執行緒？" class="headerlink" title="引入多執行緒？"></a>引入多執行緒？</h3><p>確實在 4.0 版本中 Redis 引入多執行緒，這是因為後續加入了可異步處理的刪除操作。</p><table><thead><tr><th align="left">Async</th><th align="left">Sync</th></tr></thead><tbody><tr><td align="left">UNLINK</td><td align="left">DEL</td></tr><tr><td align="left">FLUSHALL ASYNC</td><td align="left">FLUSHALL</td></tr><tr><td align="left">FLUSHDB ASYNC</td><td align="left">FLUSHDB</td></tr></tbody></table><p>要刪除容量不大（ Memory Size ）的鍵值對不會花太多功夫，所以就算單執行緒<strong>同步地</strong>刪除也不太會阻塞到其它操作。</p><p>不過 Redis 也可能有巨型資料存在，動輒十幾 MB 或是幾百 MB 都可能，而這種龐大的資料不可能短時間內處理完，這樣會導致其它操作卡住。</p><p>異步版本的刪除命令，原理是先將 Key 給移除，而實際上 Value 的刪除則是透過其它執行緒來執行，這樣就可以在刪除大型資料時也不導致 Redis 卡住。</p><p>至於在 6.0 的多執行緒 I/O 主要是用來處理網路的讀寫，也就是實際上命令的執行依然維持在單執行緒。</p><h2 id="啟動與連線"><a href="#啟動與連線" class="headerlink" title="啟動與連線"></a>啟動與連線</h2><p>Redis 服務啟動時沒有傳入任何參數的話，預設會監聽 Port 6379 ，可以透過 <code>--port</code> 或是指定設定檔，但是設定檔要自己建立。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 透過參數指定 Port</span></span><br><span class="line">$ redis-server --port 6666</span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過設定檔</span></span><br><span class="line">$ redis-server redis.conf</span><br></pre></td></tr></table></figure><p>之後就可以藉由 redis-cli 來連線到 Redis ，直接執行時如果沒設定參數，會連向本地的 6379 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>要遠端連接需要透過 <code>-h</code> 指定 Host ； <code>-p</code> 指定 Port 。</p><h3 id="密碼"><a href="#密碼" class="headerlink" title="密碼"></a>密碼</h3><p>Redis 是可以設置密碼的，有兩種方式，分別是設定檔與操作命令。</p><p>設定檔只需要加入 <code>requirepass PASSWORD</code> 這段訊息，並在 Redis Server 啟動時指定使用該設定檔即可。</p><p>透過命令的話先連線至已啟動的 Redis Server ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先連線到 Redis Server</span></span><br><span class="line">$ redis-cli</span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的命令可以看目前密碼是否有設置</span></span><br><span class="line">127.0.0.1:6379&gt; CONFIG GET requirepass</span><br><span class="line">1) <span class="string">"requirepass"</span></span><br><span class="line">2) <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過 SET 來設置密碼（ requirepass ）</span></span><br><span class="line">127.0.0.1:6379&gt; CONFIG SET requirepass <span class="string">"PASSWORD"</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>當看到 OK 後如果在執行一次 GET 會出現錯誤訊息「 (error) NOAUTH Authentication required. 」，這樣就得透過認證命令來獲取權限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; AUTH <span class="string">"PASSWORD"</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>除了透過這種方式登入有設定密碼的 Redis ，也可以在執行 redis-cli 時透過 <code>-a</code> 來傳遞密碼：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -a PASSWORD</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>但這種方式並不推薦，原因在於 <code>-a</code> 送出的密碼會是明文傳遞，很容易被他人攔截到，所以大多情況還是建議使用 <code>AUTH</code> 命令來驗證。</p><blockquote><p>注意要移除密碼不是透過 <code>DEL</code> ，而是要透過 <code>SET</code> 將密碼設定為 “” （空字串）</p></blockquote><h3 id="設定檔"><a href="#設定檔" class="headerlink" title="設定檔"></a>設定檔</h3><p>Redis 啟動時都會使用一組設定檔，沒有指定時會使用預設值。</p><p>設定檔可以指定多種不同的資訊，如前述的密碼，或是開啟主從式架構的關係等，如果想知道當前的設定檔資訊，可以透過前綴 <code>CONFIG</code> 搭配 <code>GET</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 回傳的訊息中，奇數為設定的名稱；偶數為設定的值</span></span><br><span class="line">127.0.0.1:6379&gt; CONFIG GET *</span><br><span class="line">1) <span class="string">"dbfilename"</span></span><br><span class="line">2) <span class="string">"dump.rdb"</span></span><br><span class="line">3) <span class="string">"requirepass"</span></span><br><span class="line">4) <span class="string">""</span></span><br><span class="line">...</span><br><span class="line">213) <span class="string">"bind"</span></span><br><span class="line">214) <span class="string">""</span></span><br></pre></td></tr></table></figure><p>另外也能用 <code>INFO</code> 命令可以看當前 Redis 的相關資訊。</p><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><p>說起 Map 結構，其實核心操作不過就是 Get 與 Set 而已。</p><p>Redis 支援多種資料型態：</p><ol><li>String</li><li>List</li><li>Set</li><li>Hash</li><li>Sorted Set</li><li>Bitmap</li><li>HyperLogLog</li></ol><p>後面有兩個詭異的型態，但這邊先不介紹，通常我們會使用的應該只有前幾個，大部分的命令可以<a href="https://redis.io/commands" target="_blank" rel="noopener" title="Redis Commands">到此</a>查詢。</p><blockquote><p>上列表中沒有出現 Number / Numeric 型態，因為 Redis 會把值都會轉換成 String 儲存，因此部份與數字相關的操作（ <code>INCR</code> 、 <code>DECR</code> ），實際上都是先將其轉換為數字才處理</p></blockquote><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>可以透過 <code>SET</code> 設置指定 Key 與其相對的 Value （型態為 String ），也能藉由 <code>GET</code> 取出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 設定 name - Neko 鍵值對</span></span><br><span class="line">127.0.0.1:6379&gt; SET name <span class="string">"Neko"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 藉由 Key 取出對應的 Value</span></span><br><span class="line">127.0.0.1:6379&gt; GET name</span><br><span class="line"><span class="string">"Neko"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 讀取不存在的 Key 會收到 nil</span></span><br><span class="line">127.0.0.1:6379&gt; GET neko</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p>如果值不包含空白，可以不加入雙引號：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SET name Neko</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; GET name</span><br><span class="line">&quot;Neko&quot;</span><br></pre></td></tr></table></figure><p>當儲存的 Value 是可以被轉換成數字（ Integer 、 Float ），就可以使用數字相關的操作，好比說加減的 <code>INCR</code> 與 <code>DECR</code> （各自等於 <code>INCRBY 1</code> 與 <code>DECRBY 1</code> ）。</p><blockquote><p>如果增減的值屬於浮點數請改用 <code>INCRBYFLOAT</code> ，否則會出現型態轉換錯誤</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 設置數字的 Value</span></span><br><span class="line">127.0.0.1:6379&gt; SET num <span class="string">"1"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 透過 INCR 加一，會回傳加完後的值</span></span><br><span class="line">127.0.0.1:6379&gt; INCR num</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 想指定增加的值就需使用 INCRBY</span></span><br><span class="line">127.0.0.1:6379&gt; INCRBY num 3</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 減的操作相似，不用加上負號</span></span><br><span class="line">127.0.0.1:6379&gt; DECRBY num 3</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增減的值如果是 Float 就需用 INCRBYFLOAT （不論加或減）</span></span><br><span class="line">127.0.0.1:6379&gt; INCRBYFLOAT num 0.5</span><br><span class="line"><span class="string">"2.5"</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; INCRBYFLOAT num -0.5</span><br><span class="line"><span class="string">"2"</span></span><br></pre></td></tr></table></figure><p>注意，對於 <code>INCRBY</code> 與 <code>DECRBY</code> 命令的回傳值都會做 Integer 轉換，所以假使你的值為 Float ，那麼回傳值可能會出現錯誤「 (error) ERR value is not an integer or out of range 」。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SET f 0.5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 這種情況下會視為失敗，會保持原本的值</span></span><br><span class="line">127.0.0.1:6379&gt; INCR f</span><br><span class="line">(error) ERR value is not an <span class="built_in">integer</span> or out of range</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; GET f</span><br><span class="line"><span class="string">"0.5"</span></span><br></pre></td></tr></table></figure><p>也有命令可以一次存取多個鍵值對，這些命令前方會多 M （ <code>MSET</code> 、 <code>MGET</code> ），用法基本上是沒有差別的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 透過空白隔離多個鍵值對</span></span><br><span class="line">127.0.0.1:6379&gt; MSET name <span class="string">"Doge"</span> age <span class="string">"66"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取出時會依照輸入 Key 的順序</span></span><br><span class="line">127.0.0.1:6379&gt; MGET age name</span><br><span class="line">1) <span class="string">"66"</span></span><br><span class="line">2) <span class="string">"Doge"</span></span><br></pre></td></tr></table></figure><p>Redis 在設值時有提供多種方式，可以在特定條件下才設值。<br>原本這些命令都被拆分開來，但在 2.6.12 時可以透過 <code>SET</code> 參數方式使用。</p><table><thead><tr><th align="left">Command</th><th align="left">Option</th><th align="center">Desc</th></tr></thead><tbody><tr><td align="left">SETEX</td><td align="left">EX</td><td align="center">指定過期時間，到了以後會移除（ second ）</td></tr><tr><td align="left">PSETEX</td><td align="left">PX</td><td align="center">指定過期時間，到了以後會移除（ millisecond ）</td></tr><tr><td align="left">SETNX</td><td align="left">NX</td><td align="center">當 Key 不存在時才設值</td></tr><tr><td align="left">-</td><td align="left">XX</td><td align="center">當 Key 存在時才設值</td></tr></tbody></table><p>透過參數形式的好處是可以混合多種 Option ，好比說我希望在沒有 Key 時設值，且這個值有效時間只有 10 秒，這種情況只能透過 Option 的方式設定。</p><blockquote><p>官方已不再建議使用 Command 形式，上面的三個命令可能會在未來被移除</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下方兩種方式結果是一樣的</span></span><br><span class="line">127.0.0.1:6379&gt; SET secret <span class="string">"abc123"</span> EX 10</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SETEX secret 10 <span class="string">"abc123"</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 混合 Option 當 Key 不存在才設值且有效時間為 5 秒</span></span><br><span class="line">127.0.0.1:6379&gt; SET secret <span class="string">"abc123"</span> NX EX 5</span><br></pre></td></tr></table></figure><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>Redis 的 List 是單純的 String List ，使用時可以將元素放入頭或尾。<br>其實就是 Linked List ，據官方的說明可以儲存 2^32 - 1 個元素（ 4,294,967,295 ）。</p><p>增加元素時會確認是否已存在 List ，不存在時會自動建立，而透過命令移除元素時如果會使 List 為空，則會移除該 Key 。</p><blockquote><p>意思是如果 List 被清空，那麼等於此 Key 沒被設置過</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 元素放入的方式有左與右（ LPUSH 、 RPUSH ），並回傳當前 List 長度</span></span><br><span class="line">127.0.0.1:6379&gt; LPUSH nums <span class="string">"10"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; RPUSH nums <span class="string">"20"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># LRANGE 可以取出指定 Key 的 Start Index 到 End Index 的值</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE nums 0 -1</span><br><span class="line">1) <span class="string">"10"</span></span><br><span class="line">2) <span class="string">"20"</span></span><br></pre></td></tr></table></figure><p>Index 的部分支援逆向，所以例子的 -1 意思是倒數最後一個元素，整條命令就是取出 List 上所有元素。</p><p>取出元素可以基於 Index 或是如 Queue 一樣在取值時會將其移出 List ，前者就如同程式語言內常用的 List[Index] 操作；後者則是 Queue 的 Pop 操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下會建立出 [10, 20, 30] 的陣列</span></span><br><span class="line">127.0.0.1:6379&gt; RPUSH nums <span class="string">"10"</span> <span class="string">"20"</span> <span class="string">"30"</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基於 Index 取值，但不會移出 List</span></span><br><span class="line">127.0.0.1:6379&gt; LINDEX nums 0</span><br><span class="line"><span class="string">"10"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 從左取出第一個元素，並移出 List</span></span><br><span class="line">127.0.0.1:6379&gt; LPOP nums</span><br><span class="line"><span class="string">"10"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 從右取出第一個元素，並移出 List</span></span><br><span class="line">127.0.0.1:6379&gt; RPOP nums</span><br><span class="line"><span class="string">"30"</span></span><br></pre></td></tr></table></figure><p>Pop 相關的操作還有提供 Block 版本，表示如果 Pop 的對象沒有任何元素可以取出，那麼連線將 Block 直到有元素可以回傳或超時。</p><p>命令需給予超時時限（ second ），但如果給 0 則表示無限制。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果 nums 左有元素可以取出，則效果同 LPOP 否則會卡在此處直到有元素可回傳或 30 秒後</span></span><br><span class="line">127.0.0.1:6379&gt; BLPOP nums 30</span><br><span class="line">(nil)</span><br><span class="line">(30.9s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有元素的情況就如同一般 POP</span></span><br><span class="line">127.0.0.1:6379&gt; LPUSH nums <span class="string">"1"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; BLPOP nums 30</span><br><span class="line"><span class="string">"1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以一次 Block 監聽多個 Key 有沒有元素，會回傳第一個不為空的元素</span></span><br><span class="line">127.0.0.1:6379&gt; BLPOP nums names ages 30</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>單執行緒的 Redis 在處理 Block 時，會透過 Dict 來儲存 Key 與等待者的資訊，好比說 ClientID 。並在每次處理命令時都檢查是否有元素可以提供。</p><p>當然如果是這樣會導致每次跑命令都浪費時間，所以 Redis 利用兩個 Dict 來記錄，名稱分別為 <strong>blocking_keys</strong> 與 <strong>ready_keys</strong> 。</p><ul><li>blocking_keys<br>  為 Key : List&lt;Client&gt; 的 Dict ，記錄著有人等待的 Key 與等待者相關訊息。</li><li>ready_keys<br>  當 Push 的 Key 為空 List 時會檢查該 Key 是否存在於 blocking_keys 內，有的話會將相關訊息放入 ready_keys ，也是每次 Redis 處理命令時會檢查的對象。</li></ul><p>所以實際上只有在處理 Push 相關訊息時才會檢查 Block 名單，如果該 key 剛好在 Block 名單中就透過 Ready 名單通知 Server 與 Client 。</p><blockquote><p>在 <code>MULTI</code> / <code>EXEC</code> 中使用 Block 的命令，會因為交易原子性問題馬上回應，效用等同於非 Block 操作</p></blockquote><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Redis 的 Set 為無序的 String 集合，據官方所說可儲存的數量與 List 同樣為 2^32 - 1 個（ 4,294,967,295 ）。</p><p>與常見的 Set 結構一樣，內部的元素是不允許重複的。</p><p>透過 <code>SADD</code> 可以替 Set 放入元素，要是想確認某個元素是否存在於 Set 需要透過 <code>SISMEMBER</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SADD 可以一次放入多樣值，回傳 Set 操作後的元素數量</span></span><br><span class="line">127.0.0.1:6379&gt; SADD unique <span class="string">"Neko"</span> <span class="string">"Doge"</span> <span class="string">"Neko"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 檢查指定元素是否存在，回傳 Integer 存在為 1 ；不存在為 0</span></span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER unique <span class="string">"Neko"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER unique <span class="string">"Jacky"</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><p>移除 Set 內的資料可以透過 <code>SPOP</code> 與 <code>SREM</code> ，<br>但前者是<strong>隨機地</strong>移除指定 Set 的元素，後者才可以指定移除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SADD unique <span class="string">"A"</span> <span class="string">"B"</span> <span class="string">"C"</span> <span class="string">"D"</span> <span class="string">"E"</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 隨機移除兩個元素，數量省略時預設為 1</span></span><br><span class="line">127.0.0.1:6379&gt; SPOP unique 2</span><br><span class="line">1) <span class="string">"B"</span></span><br><span class="line">2) <span class="string">"D"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除指定元素， 2.4 之後可以一次移除多個，會回傳被移除的數量</span></span><br><span class="line">127.0.0.1:6379&gt; SREM unique <span class="string">"A"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假使移除不存在的元素也可以，但不會包含在移除數量中</span></span><br><span class="line">127.0.0.1:6379&gt; SREM unique <span class="string">"A"</span> <span class="string">"B"</span> <span class="string">"C"</span> <span class="string">"D"</span> <span class="string">"E"</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure><p>如果想確認 Set 目前的數量可以用 <code>SCARD</code> ，不過想知道目前裡面所有的元素內容就得透過 <code>SMEMBERS</code> 。後者的速度比較慢，以時間複雜度來說前者為 O(1) 後者為 O(N) 。</p><p>Set 本身也有比較進階的操作，好比說交集（ <code>SINTER</code> ）、聯集（ <code>SUNION</code> ）、差集（ <code>SDIFF</code> ）等，除了聯集以外，另外兩個都是以第一個 Set 為基礎去處理，而非把每個 Set 都視為平等。</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>Hash 就是鍵值皆為 String 的 Map 結構，也因此很適合用來模擬 Object 。當然，據官方所說 Hash 同樣可以儲存 2^32 - 1 組鍵值對。</p><p>以一個 JSON 物件來當例子可以更好理解 Hash 如何模擬物件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"Neko"</span>,</span><br><span class="line">    <span class="attr">"age"</span>: <span class="number">66</span>,</span><br><span class="line">    <span class="attr">"level"</span>: <span class="string">"normal"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述為擁有編號、名稱、等級等資訊的 User 物件，透過 <code>HSET</code> 來設置這個物件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 設置成功後會回傳成功加入的鍵值對數量</span></span><br><span class="line">127.0.0.1:6379&gt; HSET user:100 id 100</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.0 之後 HSET 允許一次設定多組鍵值對</span></span><br><span class="line">127.0.0.1:6379&gt; HSET user:100 name <span class="string">"Neko"</span> age 66 level <span class="string">"normal"</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.0 之前要設定多組得透過 HMSET</span></span><br><span class="line">127.0.0.1:6379&gt; HMSET user:100 name <span class="string">"Neko"</span> age 66 level <span class="string">"normal"</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><p>回傳的值是被<strong>新加入</strong>的鍵值對數量，換句話說修改是不包含在內的，這種情況會收到 0 。</p><blockquote><p>Redis 建議命名 Key 時如果有不同區段訊息，應該透過 <code>:</code> 來區隔而不是 <code>_</code></p></blockquote><p>雖說上面的例子是模擬 Object ，但是身為 Map 結構該有的操作都沒少，例如讀取某個 Key 對應的 Value ，或取出目前所有 Key 、 Value 等命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 單獨取用某個 Key 的值</span></span><br><span class="line">127.0.0.1:6379&gt; HGET user:100 name</span><br><span class="line"><span class="string">"Neko"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只取出對象目前所有的 Key</span></span><br><span class="line">127.0.0.1:6379&gt; HKEYS user:100</span><br><span class="line">1) <span class="string">"id"</span></span><br><span class="line">2) <span class="string">"name"</span></span><br><span class="line">3) <span class="string">"age"</span></span><br><span class="line">4) <span class="string">"level"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只取出對象目前所有的 Value</span></span><br><span class="line">127.0.0.1:6379&gt; HVALS user:100</span><br><span class="line">1) <span class="string">"100"</span></span><br><span class="line">2) <span class="string">"Neko"</span></span><br><span class="line">3) <span class="string">"66"</span></span><br><span class="line">4) <span class="string">"normal"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把全部鍵值對都取出來，奇數為 Key ；偶數為 Value</span></span><br><span class="line">127.0.0.1:6379&gt; GETALL user:100</span><br><span class="line">1) <span class="string">"id"</span></span><br><span class="line">2) <span class="string">"100"</span></span><br><span class="line">3) <span class="string">"name"</span></span><br><span class="line">4) <span class="string">"Neko"</span></span><br><span class="line">5) <span class="string">"age"</span></span><br><span class="line">6) <span class="string">"66"</span></span><br><span class="line">7) <span class="string">"level"</span></span><br><span class="line">8) <span class="string">"normal"</span></span><br></pre></td></tr></table></figure><p>如果要移除 Hash 的某組鍵值對，需要透過 <code>HDEL</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 移除時會回傳成功移除掉的鍵值對數量</span></span><br><span class="line">127.0.0.1:6379&gt; HDEL user:100 name</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 2.4 版之後可以一次移除多個</span></span><br><span class="line">127.0.0.1:6379&gt; HDEL user:100 id age level</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure><p>如果 Hash 只儲存少數 Fields （一百個左右），只會佔用很小的空間，也就是說即使是一個微小的 Redis Server 也可以用來儲存百萬個 Object 而不用擔心。</p><h3 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h3><p>可排序的 Set ，<br>對，就這樣，連原理都蠻單純的。</p><p>Sorted Set 在儲存資料時會對應到一個分數（ Score ），這個分數就是拿來做排序的關鍵，排序上通常會以低 -&gt; 高。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一般的 Set</span></span><br><span class="line">127.0.0.1:6379&gt; SADD <span class="built_in">set</span>:normal <span class="string">"Neko"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可排序的 Set</span></span><br><span class="line">127.0.0.1:6379&gt; ZADD <span class="built_in">set</span>:sorted 1 <span class="string">"Neko"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><p>雖然 Set 結構不允許出現重複的元素，但是分數是可以重複的，官方對於分數重複的描述為：</p><blockquote><p>While the same element can’t be repeated in a sorted set since every element is unique, it is possible to add multiple different elements having the same score. When multiple elements have the same score, they are ordered lexicographically (they are still ordered by score as a first key, however, locally, all the elements with the same score are relatively ordered lexicographically).</p></blockquote><p>當分數一致時，會透過位元排序，也就是會將 String 視為 Byte Array 來做比對。</p><p>Sorted Set 除了最基礎的 Set 操作，還有許多獨自擁有的，例如說檢查某個元素當前排名 <code>ZRANK</code> ，查看指定元素目前的分數的 <code>ZSCORE</code> 等。</p><p>Sorted Set 有排序的關係，取出存在的元素不是 <code>ZMEMBERS</code> ，而是要改用 <code>ZRANGE</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZADD sorted 1 <span class="string">"A"</span> 2 <span class="string">"B"</span> 3 <span class="string">"C"</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此處的 0 與 -1 是表示排名，也就是第一名到最後一名全部顯示</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGE sorted 0 -1</span><br><span class="line">1) <span class="string">"A"</span></span><br><span class="line">2) <span class="string">"B"</span></span><br><span class="line">3) <span class="string">"C"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想一併知道分數，可以透過給予 WITHSCORES 參數</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGE sorted 0 -1 WITHSOCRES</span><br><span class="line">1) <span class="string">"A"</span></span><br><span class="line">2) <span class="string">"1"</span></span><br><span class="line">3) <span class="string">"B"</span></span><br><span class="line">4) <span class="string">"2"</span></span><br><span class="line">5) <span class="string">"C"</span></span><br><span class="line">6) <span class="string">"3"</span></span><br></pre></td></tr></table></figure><p>也可以透過可排序功能與 Pop 操作，來對任務做權重分配，例如新增會員 Score = 1 而修改會員資料 Score = 3 ，配置對應的 Worker 來取出目前等待中的任務。</p><p>但這樣處理時需要注意，假如進來的任務全都是權重高的，就會變成權重低的任務一直沒有處理的情況。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 透過 Block 系列的 Pop 來等待任務， MIN 指的是 Score 最小的</span></span><br><span class="line">127.0.0.1:6379&gt; BZPOPMIN events 0</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先建立一個 Sorted Set</span></span><br><span class="line">127.0.0.1:6379&gt; ZADD tasks 1 <span class="string">"create"</span> 2 <span class="string">"modify"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一樣可以監聽多個 Key ，成功收到後的訊息為三個 Key, Value, Score</span></span><br><span class="line">127.0.0.1:6379&gt; BZPOPMIN events tasks 0</span><br><span class="line">1) <span class="string">"tasks"</span></span><br><span class="line">2) <span class="string">"create"</span></span><br><span class="line">3) <span class="string">"1"</span></span><br></pre></td></tr></table></figure><p>Block 相關的原理請參考 <a href="#List">List</a> 末段 Block 操作。</p><h2 id="事務"><a href="#事務" class="headerlink" title="事務"></a>事務</h2><p>Transaction 是個術語，意思是操作是否能提供 <a href="https://zh.wikipedia.org/wiki/ACID" target="_blank" rel="noopener">ACID</a> 特性。</p><p>這種需求通常跟交易有關，譬如轉賬是從 A 帳戶轉移金錢到 B 帳戶，雖然看起來只需要兩步驟：</p><ol><li>A 扣錢</li><li>B 加錢</li></ol><p>但這涉及到操作的不安全性就沒這麼簡單。</p><p>好比說 A 已經扣除 1000$ ，但這時幫 B 增加 1000$ 失敗呢？會變成 A 損失 1000$ ，<br>又好比 A 扣錢失敗，但 B 卻成功增加 1000$ 。</p><p>Redis 提供了開始事務的 <code>MULTI</code> 與執行事務的 <code>EXEC</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先設置帳戶 A 與帳戶 B 的金額（各 5000 ）</span></span><br><span class="line">127.0.0.1:6379&gt; HSET bank:a money 5000</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; HSET bank:b money 5000</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 開始事務，此命令永遠都會回傳 OK</span></span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將帳戶 A 的金額扣除 1000 的操作加入事務中</span></span><br><span class="line">127.0.0.1:6379&gt; HINCRBY bank:a money -1000</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"><span class="comment"># 將帳戶 B 的金額增加 1000 的操作加入事務中</span></span><br><span class="line">127.0.0.1:6379&gt; HINCRBY bank:b money 1000</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"><span class="comment"># 執行事務中的操作，會回傳每個操作的結果</span></span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">1) (<span class="built_in">integer</span>) 4000</span><br><span class="line">2) (<span class="built_in">integer</span>) 6000</span><br></pre></td></tr></table></figure><p>但是與大多數人理解的事務不同的是， Redis 透過 <code>MULTI</code> / <code>EXEC</code> 的操作只能保持原子性，卻無法保持成功一同成功，失敗一同失敗，因為它不具有 Roll Back （回朔）功能。</p><p>換句話說依然可能存在 A 扣款 B 沒入款的情況，而 Redis 之所以不支援 Roll Back 的原因有二：</p><ol><li>Redis 命令失敗的情況只有錯誤的語法使用（且無法於 QUEUED 時發現），這種情況屬於程式邏輯錯誤，不應該出現在生產環境中</li><li>因為不支援 Roll Back 可以使 Redis 保持簡單與快速</li></ol><p>即使如此 Redis 也提供 <code>WATCH</code> 命令以確保與程式搭配時的 Check-And-Set （ CAS ）行為，透過 <code>WATCH</code> 可以監視指定的 Keys 是否有被更改過，如果被更改會會導致 Transaction 執行失敗。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># WATCH 必須在 MULTI 前使用</span></span><br><span class="line">127.0.0.1:6379&gt; WATCH counter</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 開始事務</span></span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把 counter 增加 1</span></span><br><span class="line">127.0.0.1:6379&gt; INCR counter</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"><span class="comment"># 執行事務，此時假設有其它 Client 修改過 counter ，回應會收到 nil</span></span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p>很明顯是種樂觀鎖，等於對事務執行設置了前置條件，以沒人改變監視的 Keys 為依據。</p><p>使用 <code>WATCH</code> 時要小心，一旦碰上 <code>EXEC</code> 與 <code>DISCARD</code> 都會取消目前所有監視的 Keys ，因為前者是執行事務後者則是放棄事務。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>實際上使用 <code>MULTI</code> 時會改變 Client 端的模式，也就是轉換為事務模式。</p><p>當處在事務模式的 Client 只要不執行 <code>EXEC</code> 、 <code>DISCARD</code> 都不會取消事務模式，這個模式中的所有命令都會被保存在一個 Queue 內，並回應訊息 『 QUEUED 』。</p><p>當執行 <code>EXEC</code> 後會將 Queue 內的命令傳送給 Server ，它便會依照順序依次執行與記錄結果，最終將事務的結果回傳給 Client 。</p><h3 id="Lua-Script"><a href="#Lua-Script" class="headerlink" title="Lua Script"></a>Lua Script</h3><p>2.6 時 Redis 引入了 Lua 執行環境，也就是 2.6 版本之後就內建一個 Lua 的 Interpreter ，而 <a href="https://www.lua.org/" target="_blank" rel="noopener">Lua</a> 是一個極輕量的語言，它的目標是成為最容易嵌入其它語言的程式語言。</p><p>Redis 對於 Lua 的環境做了許多修改，以避免產生漏洞遭利用，此外也提供由 Lua 呼叫 Redis 命令的函式等。並且為了支援持久化功能， Redis 限制了 Lua 函式必須符合三點：</p><ol><li>沒有副作用</li><li>沒有有害的隨機性（比如隨機寫一個鍵值對）</li><li>同樣的輸入必得出同樣的結果</li></ol><p>Redis 保證了 Lua 的原子性，也就是當執行 Lua Script 時不會在中間執行其它 Lua Script 或 Redis Command 。</p><p>換句話說 Lua Script 本身就是一種 Transaction ，而且還比原本 <code>MULTI</code> / <code>EXEC</code> 更快更簡單。官方雖然短時間內不會移除舊版本的事務機制，但假使未來的使用者都傾向使用 Lua Script 來處理的話，最終可能會把舊有機制給移除。</p><p>我自己感覺 Lua Script 提供更多功能與靈活性，若沒特殊原因應該也會選擇 Lua ，但這邊不會再詳細介紹 Lua ，可能未來會找時間寫相關的雜學。</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://redis.io/" target="_blank" rel="noopener" title="官方網站">Redis</a></li><li><a href="https://draveness.me/whys-the-design-redis-single-thread" target="_blank" rel="noopener" title="面向信仰编程">为什么 Redis 选择单线程模型 · Why’s THE Design?</a></li><li><a href="http://redisbook.com/index.html" target="_blank" rel="noopener">Redis 设计与实现</a></li><li><a href="https://www.jianshu.com/p/xsMzfn" target="_blank" rel="noopener" title="简书">Redis阻塞操作实现原理</a></li><li><a href="http://redisdoc.com/index.html" target="_blank" rel="noopener">Redis 命令参考</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 程式 </category>
          
          <category> 資料庫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 淺入淺出 </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/10/29/hello-world/"/>
      <url>/2019/10/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Hello World</p><p>雖說原先累積了三頁左右的雜學，但因考量到幾年前的寫作方式與近乎照抄的內容，還是決定重來，果然大清除的時候對於不需要的東西要直接捨棄才好啊。</p><p>這次的 Blog 變動其實有想趁機改成用其它 Framework ，好比說 Hugo 、 Jekyll 這種，前者是 Go 語言寫的，優點是編譯速度非常快且我也比較熟悉；後者是 Ruby ，優點的話想不太到所以沒掙扎很久，雖然我有朋友大力推薦這門語言，但對它一直沒感覺。</p><p>但最終還是用 Hexo ，其一是想藉此學學放很久的前端技能，其二我真的蠻喜歡這個主題，想到換成別的又得重新找就覺得很累，以上。</p><h2 id="Hello-World-？"><a href="#Hello-World-？" class="headerlink" title="Hello World ？"></a>Hello World ？</h2><p>原本是想就這樣結束，但又覺得啥東西都沒有也怪怪的，所以來補充個學程式語言時最常見的例子『 Hello World 』吧。</p><p>這個範例知名到 <a href="https://wikipedia.org/wiki/Hello_World" target="_blank" rel="noopener">Wiki</a> 有專門的頁面，就連日本在 2019-09-20 都上映了<a href="https://hello-world-movie.com/index.html" target="_blank" rel="noopener">同名電影</a>。</p><p>依據 Wiki 中所述這是在 B 語言的文件《 A Tutorial Introduction to the Language B 》提到的 Hello World 例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">  extrn a,b,c;</span><br><span class="line">  putchar(a); putchar(b); putchar(c); putchar(&apos;!*n&apos;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">a &apos;hell&apos;;</span><br><span class="line">b &apos;o, w&apos;;</span><br><span class="line">c &apos;orld&apos;;</span><br></pre></td></tr></table></figure><p>這類例子的用意很單純，因為基本上是最簡單的程式，所以適合用來介紹語言特性，比如上面就能看到 B 語言的某些特性。<br>而這位作者後來與他人共同開發知名的 C 語言，教學中舉的例子也是 Hello World ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello, world\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有多少高手的第一個語言是 C 呢？絕對多到你數不清。</p><p>所以根據人的惰性與習慣，這些人後來在撰寫教學文件時，第一個例子想到 Hello World 就一點也不奇怪了。</p>]]></content>
      
      
      <categories>
          
          <category> 雜七雜八 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
